<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scallop Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Use Scallop for Logic Programming and Neuro-symbolic Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="crash_course.html"><strong aria-hidden="true">2.</strong> Crash Course</a></li><li class="chapter-item expanded affix "><li class="part-title">Language Reference Guide</li><li class="chapter-item expanded "><a href="language/index.html"><strong aria-hidden="true">3.</strong> Scallop and Logic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/relation.html"><strong aria-hidden="true">3.1.</strong> Relations and Facts</a></li><li class="chapter-item expanded "><a href="language/rules.html"><strong aria-hidden="true">3.2.</strong> Writing Rules</a></li><li class="chapter-item expanded "><a href="language/value_type.html"><strong aria-hidden="true">3.3.</strong> Values and Types</a></li><li class="chapter-item expanded "><a href="language/query.html"><strong aria-hidden="true">3.4.</strong> Writing a Query</a></li><li class="chapter-item expanded "><a href="language/recursion.html"><strong aria-hidden="true">3.5.</strong> Recursive Rules</a></li><li class="chapter-item expanded "><a href="language/negation.html"><strong aria-hidden="true">3.6.</strong> Negations</a></li><li class="chapter-item expanded "><a href="language/aggregation.html"><strong aria-hidden="true">3.7.</strong> Aggregations</a></li><li class="chapter-item expanded "><a href="language/constants.html"><strong aria-hidden="true">3.8.</strong> Declaring Constants</a></li><li class="chapter-item expanded "><a href="language/adt_and_entity.html"><strong aria-hidden="true">3.9.</strong> Algebraic Data Type and Entities</a></li><li class="chapter-item expanded "><a href="language/magic_set.html"><strong aria-hidden="true">3.10.</strong> On-Demand Predicates</a></li><li class="chapter-item expanded "><a href="language/loading_csv.html"><strong aria-hidden="true">3.11.</strong> Loading from CSV</a></li><li class="chapter-item expanded "><a href="language/foreign_functions.html"><strong aria-hidden="true">3.12.</strong> Foreign Functions</a></li><li class="chapter-item expanded "><a href="language/foreign_predicates.html"><strong aria-hidden="true">3.13.</strong> Foreign Predicates</a></li><li class="chapter-item expanded "><a href="language/reference_guide.html"><strong aria-hidden="true">3.14.</strong> Reference Guide</a></li></ol></li><li class="chapter-item expanded "><a href="probabilistic/index.html"><strong aria-hidden="true">4.</strong> Provenance and Probabilistic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="probabilistic/provenance.html"><strong aria-hidden="true">4.1.</strong> Provenance</a></li><li class="chapter-item expanded "><a href="probabilistic/proofs.html"><strong aria-hidden="true">4.2.</strong> Proofs Provenance</a></li><li class="chapter-item expanded "><a href="probabilistic/facts.html"><strong aria-hidden="true">4.3.</strong> Fact with Probability</a></li><li class="chapter-item expanded "><a href="probabilistic/logic.html"><strong aria-hidden="true">4.4.</strong> Logic and Probability</a></li><li class="chapter-item expanded "><a href="probabilistic/library.html"><strong aria-hidden="true">4.5.</strong> Provenance Library</a></li><li class="chapter-item expanded "><a href="probabilistic/aggregation.html"><strong aria-hidden="true">4.6.</strong> Aggregation and Probability</a></li><li class="chapter-item expanded "><a href="probabilistic/sampling.html"><strong aria-hidden="true">4.7.</strong> Sampling with Probability</a></li><li class="chapter-item expanded "><a href="probabilistic/debug.html"><strong aria-hidden="true">4.8.</strong> Debugging Proofs</a></li></ol></li><li class="chapter-item expanded "><a href="scallopy/index.html"><strong aria-hidden="true">5.</strong> scallopy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scallopy/getting_started.html"><strong aria-hidden="true">5.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="scallopy/context.html"><strong aria-hidden="true">5.2.</strong> Scallop Context</a></li><li class="chapter-item expanded "><a href="scallopy/branching.html"><strong aria-hidden="true">5.3.</strong> Branching Executions</a></li><li class="chapter-item expanded "><a href="scallopy/provenance.html"><strong aria-hidden="true">5.4.</strong> Configuring Provenance</a></li><li class="chapter-item expanded "><a href="scallopy/module.html"><strong aria-hidden="true">5.5.</strong> Creating Module</a></li><li class="chapter-item expanded "><a href="scallopy/module_input.html"><strong aria-hidden="true">5.6.</strong> Configuring Input Relations</a></li><li class="chapter-item expanded "><a href="scallopy/module_output.html"><strong aria-hidden="true">5.7.</strong> Configuring Output Relations</a></li><li class="chapter-item expanded "><a href="scallopy/foreign_function.html"><strong aria-hidden="true">5.8.</strong> Foreign Functions</a></li><li class="chapter-item expanded "><a href="scallopy/foreign_predicate.html"><strong aria-hidden="true">5.9.</strong> Foreign Predicate</a></li><li class="chapter-item expanded "><a href="scallopy/save_and_load.html"><strong aria-hidden="true">5.10.</strong> Saving and Loading</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Toolchain</li><li class="chapter-item expanded "><a href="toolchain/cli.html"><strong aria-hidden="true">6.</strong> Scallop CLI</a></li><li class="chapter-item expanded "><a href="toolchain/scli.html"><strong aria-hidden="true">7.</strong> Scallop Interpreter</a></li><li class="chapter-item expanded "><a href="toolchain/sclrepl.html"><strong aria-hidden="true">8.</strong> Scallop REPL</a></li><li class="chapter-item expanded "><a href="toolchain/sclc.html"><strong aria-hidden="true">9.</strong> Scallop Compiler</a></li><li class="chapter-item expanded affix "><li class="part-title">For Developers</li><li class="chapter-item expanded "><a href="developer/index.html"><strong aria-hidden="true">10.</strong> For Developers</a></li><li class="chapter-item expanded "><a href="developer/language_construct.html"><strong aria-hidden="true">11.</strong> New Language Construct</a></li><li class="chapter-item expanded "><a href="developer/binding.html"><strong aria-hidden="true">12.</strong> New Binding</a></li><li class="chapter-item expanded affix "><li class="part-title">Resources</li><li class="chapter-item expanded "><a href="grammar.html"><strong aria-hidden="true">13.</strong> Full Scallop Grammar</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Scallop Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scallop-a-language-for-neurosymbolic-programming"><a class="header" href="#scallop-a-language-for-neurosymbolic-programming">Scallop, a Language for Neurosymbolic Programming</a></h1>
<center>
  <img src="res/img/scallop-logo-ws-512.png" width="200px" />
</center>
<p>Scallop is a language based on DataLog that supports differentiable logical and relational reasoning.
Scallop program can be easily integrated in Python and even with a PyTorch learning module.
You can also use it as another DataLog solver.
This book aims to give both high-level overview of the language usage and also low-level documentation on how each language feature is used.</p>
<p>The following example shows how knowledge base facts, rules, and probabilistic facts recognized from images can operate together.</p>
<pre><code class="language-scl">// Knowledge base facts
rel is_a(&quot;giraffe&quot;, &quot;mammal&quot;)
rel is_a(&quot;tiger&quot;, &quot;mammal&quot;)
rel is_a(&quot;mammal&quot;, &quot;animal&quot;)

// Knowledge base rules
rel name(a, b) :- name(a, c), is_a(c, b)

// Recognized from an image, maybe probabilistic
rel name = {
  0.3::(1, &quot;giraffe&quot;),
  0.7::(1, &quot;tiger&quot;),
  0.9::(2, &quot;giraffe&quot;),
  0.1::(2, &quot;tiger&quot;),
}

// Count the animals
rel num_animals(n) :- n = count(o: name(o, &quot;animal&quot;))
</code></pre>
<h2 id="table-of-content"><a class="header" href="#table-of-content">Table of Content</a></h2>
<p>Please refer to the side-bar for a detailed table of content.
At a high-level, we organize this book into the following 5 sections:</p>
<h3 id="installation-and-crash-course"><a class="header" href="#installation-and-crash-course">Installation and Crash Course</a></h3>
<p><a href="installation.html">Installation</a> gives instructions on how to install the Scallop on your machine.
<a href="crash_course.html">Crash Course</a> gives a quick introduction to what the language is and how it is used.
Both sections are designed so that you can start quickly with Scallop.</p>
<h3 id="scallop-and-logic-programming"><a class="header" href="#scallop-and-logic-programming">Scallop and Logic Programming</a></h3>
<p><a href="language/index.html">Scallop and Logic Programming</a> aims to give you a detailed introduction on the language.
It introduces language features such as relational programming, negation and aggregation, queries, foreign constructs, and etc.
Reading through all of these you should be well-versed in Scallop's core functionality and you will be able to use Scallop as a Datalog engine.</p>
<pre><code class="language-scl">type fib(bound x: i32, y: i32)
rel fib = {(0, 1), (1, 1)}
rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2) and x &gt; 1
query fib(10, y)
</code></pre>
<h3 id="scallop-and-probabilistic-programming"><a class="header" href="#scallop-and-probabilistic-programming">Scallop and Probabilistic Programming</a></h3>
<p><a href="probabilistic/index.html">Scallop and Probabilistic Programming</a> introduces the probabilistic side of Scallop.
You will learn to tag facts with probabilities, its underlying algorithms and frameworks, and additional programming constructs for probabilistic semantics.
By the end of this section, you will be familiar with using Scallop as a probabilistic programming language.</p>
<pre><code class="language-scl">rel attr = { 0.99::(OBJECT_A, &quot;blue&quot;), 0.01::(OBJECT_B, &quot;red&quot;), ... }
rel relate = { 0.01::(OBJECT_A, &quot;holds&quot;, OBJECT_B), ... }
</code></pre>
<h3 id="scallopy-and-neurosymbolic-programming"><a class="header" href="#scallopy-and-neurosymbolic-programming">Scallopy and Neurosymbolic Programming</a></h3>
<p><a href="scallopy/index.html">Scallopy and Neurosymbolic Programming</a> goes into the heart of Scallop to introduce applying Scallop to write Neurosymbolic applications.
Neurosymbolic methods are for methods that have both neural and logical components.
For this, we are going to use the Python binding of Scallop, <code>scallopy</code>, to integrate with machine learning libraries such as PyTorch.
This section will be describing the API of <code>scallopy</code>.</p>
<pre><code class="language-py">sum_2 = scallopy.Module(
  program=&quot;&quot;&quot;type digit_1(i32), digit_2(i32)
             rel sum_2(a + b) = digit_1(a) and digit_2(b)&quot;&quot;&quot;,
  input_mappings={&quot;digit_1&quot;: range(10), &quot;digit_2&quot;: range(10)},
  output_mapping=(&quot;sum_2&quot;, range(19)))
</code></pre>
<h3 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h3>
<p><a href="developer/index.html">For Developers</a> discusses how developers and researchers who are interested in extending Scallop can step into the source code of Scallop and program extensions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>There are many ways in which you can use Scallop, forming a complete toolchain.
We specify how to installing the toolchain from source.
The following instructions assume you have access to the Scallop source code and have basic pre-requisites installed.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>Rust - nightly 2023-03-07 (please visit <a href="https://rust-lang.github.io/rustup/concepts/channels.html">here</a> to learn more about Rust nightly and how to install them)</li>
<li>Python 3.7+ (for connecting Scallop with Python and <a href="https://pytorch.org">PyTorch</a>)</li>
</ul>
<h2 id="scallop-interpreter"><a class="header" href="#scallop-interpreter">Scallop Interpreter</a></h2>
<p>The interpreter of Scallop is named <code>scli</code>.
To install it, please do</p>
<pre><code class="language-bash">$ make install-scli
</code></pre>
<p>From here, you can use <code>scli</code> to test and run simple programs</p>
<pre><code class="language-bash">$ scli examples/datalog/edge_path.scl
</code></pre>
<h2 id="scallop-interactive-shell"><a class="header" href="#scallop-interactive-shell">Scallop Interactive Shell</a></h2>
<h2 id="scallop-python-interface"><a class="header" href="#scallop-python-interface">Scallop Python Interface</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-and-logic-programming-1"><a class="header" href="#scallop-and-logic-programming-1">Scallop and Logic Programming</a></h1>
<p>In this part of the book we introduce Scallop as a relational and logical programming language.
Scallop is a Datalog based language extended with various language features such as negation, aggregation, disjunctive head, algebraic data type, foreign functions, and foreign predicates.
We will explain all of these concepts in detail, aiming to provide a comprehensive introduction to the core language constructs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relations-and-facts"><a class="header" href="#relations-and-facts">Relations and Facts</a></h1>
<p>Scallop is a relational and logical programming language.
As described in the <a href="https://en.wikipedia.org/wiki/Logic_programming">Wikipedia</a>:</p>
<blockquote>
<p>Logic programming is a programming paradigm which is largely based on formal logic.
Any program written in a logic programming language is a set of sentences in logical form,
expressing facts and rules about some problem domain.</p>
</blockquote>
<p>In Scallop, relations are the most fundamental building blocks of program.
In the following example, we have declared the type of a relation called <code>edge</code>, using the <code>type</code> keyword:</p>
<pre><code class="language-scl">type edge(a: i32, b: i32)
</code></pre>
<p>We say that the name <code>edge</code> is a <em>predicate</em> or a <em>relation</em>.
Inside of the parenthesis, we have two <code>arguments</code>, <code>a: i32</code> and <code>b: i32</code>.
Therefore, we have <code>edge</code> being an <em>arity-2</em> relation, due to it having 2 arguments.
For the argument <code>a: i32</code>, we give a name of the field (<code>a</code>) and a type of that argument <code>i32</code>.
Here, both of the arguments are of the <code>i32</code> type, which means signed-<em>i</em>nteger, <em>32</em>-bit.
For more information on value types, refer to <a href="language/relation.html#value-types">the Value Types section</a>.</p>
<p>The above line only declares the type of the relation but not the <em>content</em> of the relation.
The actual information stored in the relations are called <em>facts</em>.
Here we define a single fact under the relation <code>edge</code>:</p>
<pre><code class="language-scl">rel edge(0, 1)
</code></pre>
<p>Assuming <code>0</code> and <code>1</code> each denote an ID of a node, this fact declares that there is an edge going from node <code>0</code> to node <code>1</code>.
There are two arguments in this fact, matching the arity of this relation.
Regardless of the predicate <code>edge</code>, one also simply consider the <code>(0, 1)</code> as a <em>tuple</em>, more specifically, a <em>2-tuple</em>.</p>
<p>To declare multiple facts, one can simply write multiple single fact declaration using the <code>rel</code> keyword, like</p>
<pre><code class="language-scl">rel edge(0, 1)
rel edge(1, 2)
</code></pre>
<p>One can also use the <em>set</em> syntax to declare multiple facts of a relation.
The following line reads: &quot;the relation <code>edge</code> contains a set of tuples, including <code>(0, 1)</code> and <code>(1, 2)</code>&quot;:</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2)}
</code></pre>
<p>Note that it is possible to declare multiple fact sets for the same relation.</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2)}
rel edge = {(2, 3)}
</code></pre>
<p>With the above two lines the edge relation now contains 3 facts, <code>(0, 1)</code>, <code>(1, 2)</code>, and <code>(2, 3)</code>.</p>
<h2 id="examples-of-relations"><a class="header" href="#examples-of-relations">Examples of Relations</a></h2>
<h3 id="boolean-and-0-arity-relation"><a class="header" href="#boolean-and-0-arity-relation">Boolean and 0-arity Relation</a></h3>
<p>Many things can be represented as relations.
We start with the most basic programming construct, boolean.
While Scallop allows value to have the boolean type, relations themselves can encode boolean values.
The following example contains an <em>arity-0</em> relation named <code>is_target</code>:</p>
<pre><code class="language-scl">type is_target()
</code></pre>
<p>There is only one possible tuple that could form a fact in this relation, that is the <em>empty tuple</em> <code>()</code>.
Assuming that we are treating the relation <code>is_target</code> as a set, then if the set contains no element (i.e., empty), then it encodes boolean &quot;false&quot;.
Otherwise, if the set contains exactly one (note: it can contain at most one) tuple, then it encodes boolean &quot;true&quot;.
Declaring only the type of <code>is_target</code> as above, would assume that the relation is empty.
To declare the fact, we can do:</p>
<pre><code class="language-scl">rel is_target()
// or
rel is_target = {()}
</code></pre>
<h3 id="unary-relations"><a class="header" href="#unary-relations">Unary Relations</a></h3>
<p>Unary relations are relations of arity 1.
We can define unary relations for &quot;variables&quot; as we see in other programming languages.
The following example declares a relation named <code>greeting</code> containing one single string of <code>&quot;hello world!&quot;</code>.</p>
<pre><code class="language-scl">rel greeting(&quot;hello world!&quot;)
// or
rel greeting = {(&quot;hello world!&quot;,)}
</code></pre>
<p>Note that for the second way of expressing the fact, we may omit the parenthesis and make it cleaner:</p>
<pre><code class="language-scl">rel greeting = {&quot;hello world!&quot;}
</code></pre>
<p>In light of this, we may write the following rule:</p>
<pre><code class="language-scl">rel possible_digit = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
</code></pre>
<h3 id="integer-arithmetics-as-relations"><a class="header" href="#integer-arithmetics-as-relations">Integer Arithmetics as Relations</a></h3>
<p>Integer arithmetics can be represented as relations as well.
Consider a simple summation in algebra, <code>a + b = c</code> encodes the sum relationship among two operands (<code>a</code> and <code>b</code>) and their summation (<code>c</code>).
Encoded in Scallop, they form arity-3 relations:</p>
<pre><code class="language-scl">type add(op1: i32, op2: i32, result: i32)
</code></pre>
<p>Note that, in Scallop, relations are <em>not</em> polymorphic.
That is, every relation, no matter declared or inferred, only has one type annotation.</p>
<blockquote>
<p>We are working on an update in the future to relax this restriction.</p>
</blockquote>
<p>To declare facts of this <code>add</code> relation, such as <code>3 + 4 = 7</code>, we write</p>
<pre><code class="language-scl">rel add(3, 4, 7) // 3 + 4 = 7
</code></pre>
<p>However, you might notice that the <code>add</code> relation is theoretically <em>infinite</em>.
That is, there are infinite amount of facts that can satisfy the <code>add</code> relation.
There is no way that we can possibly enumerate or declare all the facts.
In such case, we resort to declaring rules using foreign functions or predicates, which we will discuss later.
For now, let's use <code>add</code> as an example relation that encodes integer arithmetics.</p>
<h3 id="terminologies"><a class="header" href="#terminologies">Terminologies</a></h3>
<p>We have the following terminologies for describing relations.</p>
<ul>
<li>Boolean Relation: arity-0 relation</li>
<li>Unary Relation: arity-1 relation</li>
<li>Binary Relation: arity-2 relation</li>
<li>Ternary Relation: arity-3 relation</li>
</ul>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Scallop supports <em>Type Inference</em>.
One does not need to fully annotate every relation on their types.
Types are inferred during the compilation process.</p>
<p>For example, given the following code,</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2)}
</code></pre>
<p>we can infer that the relation <code>edge</code> is a binary-relation where both arguments are integers.
Note that when integers are specified, they are set default to the type of <code>i32</code>.</p>
<p>Type inference will fail if conflicts are detected.
In the following snippet, we have the second argument being <code>1</code> as integer and also <code>&quot;1&quot;</code> as string.</p>
<pre><code class="language-scl">rel edge = {(0, 1), (0, &quot;1&quot;)}
</code></pre>
<p>Having this code will raise the following compile error, suggesting that the types cannot be unified.
Note that the following response is generated in <code>sclrepl</code> command line interface.</p>
<pre><code>[Error] cannot unify types `numeric` and `string`, where the first is declared here
  REPL:0 | rel edge = {(0, 1), (0, &quot;1&quot;)}
         |                 ^
and the second is declared here
  REPL:0 | rel edge = {(0, 1), (0, &quot;1&quot;)}
         |                         ^^^
</code></pre>
<p>For more information on values and types, please refer to the <a href="language/value_type.html">next section</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rules"><a class="header" href="#rules">Rules</a></h1>
<p><em>Rules</em> are the fundamental to computation in Scallop.
Each rule defines the value and data flowing from some relation to another relation.
In the following program, we have defined a few facts for the <code>edge</code> relation.
On the second line, we have defined that, for each edge <code>(a, b)</code>, there is also a path <code>(a, b)</code>.
We note that here, <code>a</code> and <code>b</code> are variables instead of constants as we have with defining facts.
During computation, the two facts in <code>edge</code> will populate the <code>path</code> relation.
This way, we have defined a rule for the <code>path</code>, which is executed during computation.</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2)}
rel path(a, b) = edge(a, b) // (0, 1), (1, 2)
</code></pre>
<p>In this section, we talk about how we write rules in Scallop and how intricate computation can be done through it.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>In general, the basic rules in Scallop are of the form</p>
<pre><code>RULE    ::= rel ATOM = FORMULA
FORMULA ::= ATOM
          | not ATOM
          | CONSTRAINT
          | AGGREGATION
          | FORMULA and FORMULA
          | FORMULA or FORMULA
          | ( FORMULA )
</code></pre>
<p>For each rule, we name the atom on the left to be the <em>head</em> of the rule, and the formula on the right to be the <em>body</em>.
We read it from right to left: when the body formula holds, the head also holds.
The formula might contain atoms, negated atoms, aggregations, conjunction, disjunction, and a few more constructs.
For this section, we focus on simple (positive) atom, constraints, and their conjunctions and disjunctions.
We will leave the discussion of negation and aggregation to the next sections.</p>
<h2 id="atom"><a class="header" href="#atom">Atom</a></h2>
<p>Simple atoms are of the form <code>RELATION(ARG_1, ARG_2, ...)</code>.
Similar to facts, we have the relation name followed by a tuple of numerous arguments.
Now, the arguments can be of richer forms, involving variables, constants, expressions, function calls, and many more.</p>
<p>Considering the most basic example from above:</p>
<pre><code class="language-scl">rel path(a, b) = edge(a, b)
</code></pre>
<p>We have two variables <code>a</code> and <code>b</code> <em>grounded</em> by the <code>edge</code> relation.
This means we are treating the variables <code>a</code> and <code>b</code> as source of information, which can be propagated to the head.
In this example, the head also contains two variables, both being grounded by the body.
Therefore the whole rule is well formed.</p>
<p>In case the head variables are not grounded by the body, such as the following,</p>
<pre><code class="language-scl">rel path(a, c) = edge(a, b)
</code></pre>
<p>we would get an error that looks like the following:</p>
<pre><code>[Error] Argument of the head of a rule is ungrounded
  REPL:1 | rel path(a, c) = edge(a, b)
         |             ^
</code></pre>
<p>The error message points us to the variable <code>c</code> that has not being grounded in the body.</p>
<p>For basic atoms, such as the ones that the user has defined, can be used to directly ground variables which are directly arguments of the atoms.
They can be used to ground other variables or expressions.
In the following example, although the rule itself might not make any sense, the variable <code>a</code> is used to ground the expression <code>a + 1</code>.
Therefore, the rule is completely valid.</p>
<pre><code class="language-scl">rel output_relation(a, a + 1) = input_relation(a)
</code></pre>
<p>In certain cases, expressions can be used to bound variables as well!</p>
<pre><code class="language-scl">rel output_relation(a, b) = input_relation(a, b + 1)
</code></pre>
<p>In the above example, the expression <code>b + 1</code> can be used to derive <code>b</code>, and thus making the variable <code>b</code> grounded.
However, this might not be true for other expressions:</p>
<pre><code class="language-scl">rel output_relation(b, c) = input_relation(b + c) // FAILURE
</code></pre>
<p>The <code>input_relation</code> can ground the expression <code>b + c</code> directly, however, the two arguments <code>b</code> and <code>c</code> cannot be derived from their sum, as there are (theoretically) infinite amount of combinations.
In this case, we will get a compilation failure.</p>
<p>There can be constraints present in atoms as well.
For example, consider the following rule:</p>
<pre><code class="language-scl">rel self_edge(a) = edge(a, a)
</code></pre>
<p>The atom <code>edge(a, a)</code> in the body grounds only one variable <code>a</code>.
But the pattern is used to match any edge that goes from <code>a</code> and to <code>a</code> itself.
Therefore, instead of grounding two values representing the &quot;from&quot; and &quot;to&quot; of an <code>edge</code>, we are additionally posing constraint on the type of edge that we are matching.
Conceptually, we can view the above rule as the following equivalent rule:</p>
<pre><code class="language-scl">rel self_edge(a) = edge(a, b) and a == b
</code></pre>
<p>where there is an additional constraint posed on the equality of <code>a</code> and <code>b</code>.
We are going to touch on <code>and</code> and constraints in the upcoming sections.</p>
<h2 id="disjunction-or"><a class="header" href="#disjunction-or">Disjunction (Or)</a></h2>
<p>The body formula can contain logical connectives such as <code>and</code>, <code>or</code>, <code>not</code>, and <code>implies</code>, used to connect basic formulas such as <em>Atom</em>.
In the following example, we are defining that if <code>a</code> is <code>b</code>'s <em>father</em> or <em>mother</em>, then <code>a</code> is <code>b</code>'s parent:</p>
<pre><code class="language-scl">rel parent(a, b) = father(a, b)
rel parent(a, b) = mother(a, b)
</code></pre>
<p>In this program, we have divided the derivation of <code>parent</code> into two separate rules, one processing the <code>father</code> relationship and the other processing the <code>mother</code> relationship.
This natually form a disjunction (or), as the derivation of <code>parent</code> can come from 2 disjunctive sources.
Note that in Scallop (or Datalog in general), the ordering of the two rules does not matter.</p>
<p>Therefore, given that</p>
<pre><code class="language-scl">rel father = {(&quot;Bob&quot;, &quot;Alice&quot;)}
rel mother = {(&quot;Christine&quot;, &quot;Alice&quot;)}
</code></pre>
<p>we can derive that the <code>parent</code> relation holding two tuples, <code>(&quot;Bob&quot;, &quot;Alice&quot;)</code> and <code>(&quot;Christine&quot;, &quot;Alice&quot;)</code>.</p>
<p>The above program can be rewritten into a more compact form that looks like the following:</p>
<pre><code class="language-scl">rel parent(a, b) = father(a, b) or mother(a, b)
// or
rel parent(a, b) = father(a, b) \/ mother(a, b)
</code></pre>
<p>We have used an explicit <code>or</code> (<code>\/</code>) keyword to connect the two atoms, <code>father(a, b)</code> and <code>mother(a, b)</code>.
The <code>\/</code> symbol, which is commonly seen in the formal logics as the symbol vee (\(\vee\)), is also supported.
Notice that written in this way, each branch of the disjunction need to fully bound the variables/expressions in the head.</p>
<h2 id="conjunction-and"><a class="header" href="#conjunction-and">Conjunction (And)</a></h2>
<p>To demonstrate the use of <code>and</code>, let's look at the following example computing the relation of <code>grandmother</code> based on <code>father</code> and <code>mother</code>:</p>
<pre><code class="language-scl">rel grandmother(a, c) = mother(a, b) and father(b, c)
// or
rel grandmother(a, c) = mother(a, b) /\ father(b, c)
</code></pre>
<p>Notice that the symbol <code>/\</code> is a replacement for the <code>and</code> operator, which resembles the wedge (\(\wedge\)) symbol seen in formal logics.</p>
<p>As can be seen from the rule, the body grounds three variables <code>a</code>, <code>b</code>, and <code>c</code>.
The variables <code>a</code> and <code>b</code> comes from <code>mother</code> and the variables <code>b</code> and <code>c</code> comes from <code>father</code>.
Notice that there is one variable, <code>b</code>, in common.
In this case, we are <em>joining</em> the relation of <code>mother</code> and <code>father</code> on the variable <code>b</code>.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>Rule body can have boolean constraints.
For example, the conjunctive rule above can be re-written as</p>
<pre><code class="language-scl">rel grandmother(a, c) = mother(a, b) and father(bp, c) and b == bp
</code></pre>
<p>Here, we are posing an equality (<code>==</code>) constraint on <code>b</code> and <code>bp</code>.
Normally, constraints are such kind of binary expressions involving predicates such as</p>
<ul>
<li>equality and inequality (<code>==</code> and <code>!=</code>)</li>
<li>numerical comparisons (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>)</li>
</ul>
<h2 id="other-constructs"><a class="header" href="#other-constructs">Other constructs</a></h2>
<p>There are other constructs available for defining rules, which we continue to discuss in detail in other sections:</p>
<ul>
<li><a href="language/disj_conj_head.html">Disjunctive head</a></li>
<li><a href="language/recursion.html">Recursive Rules</a></li>
<li><a href="language/negation.html">Negation</a></li>
<li><a href="language/aggregation.html">Aggregation</a></li>
<li><a href="language/foreign_predicates.html">Foreign Predicates</a></li>
</ul>
<h2 id="traditional-datalog-syntax"><a class="header" href="#traditional-datalog-syntax">Traditional Datalog Syntax</a></h2>
<p>If you are familiar with traditional Datalog, you can have it by swapping the <code>=</code> with <code>:-</code>, and the <code>and</code> to <code>,</code>
For example, the rule for defining <code>grandmother</code> can be rewritten as</p>
<pre><code class="language-scl">rel grandmother(a, c) :- mother(a, b), father(b, c)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="values-and-types"><a class="header" href="#values-and-types">Values and Types</a></h1>
<p>Scallop has a built-in set of basic value types, following Rust's naming convention.
From there, we have types such as <code>Symbol</code>, <code>DateTime</code>, <code>Entity</code>, and <code>Tensor</code>, which are special types to Scallop.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>Signed-integer, 8-bit</td></tr>
<tr><td><code>i16</code></td><td>Signed-integer, 16-bit</td></tr>
<tr><td><code>i32</code></td><td>Signed-integer, 32-bit</td></tr>
<tr><td><code>i64</code></td><td>Signed-integer, 64-bit</td></tr>
<tr><td><code>i128</code></td><td>Signed-integer, 128-bit</td></tr>
<tr><td><code>isize</code></td><td>Signed size; its size is dependent on the system</td></tr>
<tr><td><code>u8</code></td><td>Unsigned-integer, 8-bit</td></tr>
<tr><td><code>u16</code></td><td>Unsigned-integer, 16-bit</td></tr>
<tr><td><code>u32</code></td><td>Unsigned-integer, 32-bit</td></tr>
<tr><td><code>u64</code></td><td>Unsigned-integer, 64-bit</td></tr>
<tr><td><code>u128</code></td><td>Unsigned-integer, 128-bit</td></tr>
<tr><td><code>usize</code></td><td>Unsigned size; its size is dependent on the system</td></tr>
<tr><td><code>f32</code></td><td>Floating-point number, 32-bit</td></tr>
<tr><td><code>f64</code></td><td>Floating-point number, 64-bit</td></tr>
<tr><td><code>bool</code></td><td>Boolean</td></tr>
<tr><td><code>char</code></td><td>Character</td></tr>
<tr><td><code>String</code></td><td>Variable-length string</td></tr>
<tr><td><code>Symbol</code></td><td>Symbol</td></tr>
<tr><td><code>DateTime</code></td><td>Date and time</td></tr>
<tr><td><code>Duration</code></td><td>Duration</td></tr>
<tr><td><code>Entity</code></td><td>Entity</td></tr>
<tr><td><code>Tensor</code></td><td>Tensor</td></tr>
</tbody></table>
</div>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Integers are the most basic data-type in Scallop.
If not specified, the default integer type that the system will pick is the <code>i32</code> (signed integer 32-bit) type:</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2)} // (i32, i32)
</code></pre>
<p>If an unsigned integer type is specified but a negative number is used in the declared facts, a type inference error will be raised.
We demonstrate this in the <code>sclrepl</code> environment:</p>
<pre><code>scl&gt; type my_edge(usize, usize)
scl&gt; rel my_edge = {(-1, -5), (0, 3)}
[Error] cannot unify types `usize` and `signed integer`, where the first is declared here
  REPL:0 | type my_edge(usize, usize)
         |              ^^^^^
and the second is declared here
  REPL:1 | rel my_edge = {(-1, -5), (0, 3)}
         |                 ^^
</code></pre>
<p>Primitive operations that can be used along with integers are</p>
<ul>
<li>Comparators:
<ul>
<li><code>==</code> (equality)</li>
<li><code>!=</code> (inequality)</li>
<li><code>&gt;</code> (greater-than)</li>
<li><code>&gt;=</code> (greater-than-or-equal-to)</li>
<li><code>&lt;</code> (less-than)</li>
<li><code>&lt;=</code> (less-than-or-equal-to)</li>
</ul>
</li>
<li>Arithmetic operators:
<ul>
<li><code>+</code> (plus)</li>
<li><code>-</code> (minus/negate)</li>
<li><code>*</code> (mult)</li>
<li><code>/</code> (div)</li>
<li><code>%</code> (mod)</li>
</ul>
</li>
</ul>
<p>All of the above operations need to operate on two integers of the same type.
For instance, you cannot compare an <code>i32</code> value with a <code>usize</code> value.</p>
<h3 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating Point Numbers</a></h3>
<p>Floating point numbers are supported in Scallop as well.
The following example shows the definition of student and their class grades:</p>
<pre><code class="language-scl">type student_grade(name: String, class: String, grade: f32)

rel student_grade = {
  (&quot;alice&quot;, &quot;cse 100&quot;, 95.2),
  (&quot;bob&quot;, &quot;cse 100&quot;, 90.8),
}
</code></pre>
<p>It is possible derive special floating points such as <code>inf</code> and <code>-inf</code>, though we cannot declare such values directly.
For the floating point that is <code>nan</code> (not-a-number), we will omit the whole fact from the database to maintain sanity.
Specifically, the derivation of <code>nan</code> is treated as a failure of foreign functions, which we explain in detail <a href="language/foreign_functions.html">here</a>.</p>
<p>All the basic operations that can work on integers would be able to work for floating point numbers as well.</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>Scallop allows the use of boolean values (<code>true</code> and <code>false</code>).</p>
<pre><code class="language-scl">type variable_assign(String, bool)
rel variable_assign = {(&quot;a&quot;, true), (&quot;b&quot;, false)}
</code></pre>
<p>We support the following boolean operations:</p>
<ul>
<li>Comparisons
<ul>
<li><code>==</code> (equality)</li>
<li><code>!=</code> (inequality)</li>
</ul>
</li>
<li>Logical operations
<ul>
<li><code>!</code> (unary negate)</li>
<li><code>&amp;&amp;</code> (binary and)</li>
<li><code>||</code> (binary or)</li>
<li><code>^</code> (binary xor)</li>
</ul>
</li>
</ul>
<p>For example, we can have the following code</p>
<pre><code class="language-scl">rel result(a ^ b) = variable_assign(&quot;a&quot;, a) and variable_assign(&quot;b&quot;, b) // true
</code></pre>
<h3 id="character"><a class="header" href="#character">Character</a></h3>
<p>Scallop allows definition of characters such as <code>'a'</code>, <code>'*'</code>.
They are single-quoted, and can contain escaped characters such as <code>'\n'</code> (new-line) and <code>'\t'</code> (tab).</p>
<pre><code class="language-scl">type my_chars = {(0, 'h'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')}
</code></pre>
<p>Comparisons operations <code>==</code> and <code>!=</code> are available for characters.</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>Scallop support variable length strings of the type <code>String</code>.
Strings are declared using the double quote (<code>&quot;</code>), and can contain escaped characters such as <code>\n</code> and <code>\t</code>.</p>
<pre><code class="language-scl">rel greeting = {&quot;Hello World&quot;}
</code></pre>
<p>Strings can certainly be compared using <code>==</code> and <code>!=</code>.
The main ways for interacting with strings are through foreign functions such as <code>$string_length</code>, <code>$substring</code>, <code>$string_concat</code>, and etc.
Please refer to the <a href="language/foreign_functions.html">foreign functions section</a> for more information.</p>
<h3 id="symbols"><a class="header" href="#symbols">Symbols</a></h3>
<p>Symbols are internally registered strings.
They are most commonly created through <a href="language/loading_csv.html">loading from external files</a>.
But they can still be specified using the <code>s</code>-quoted-string notation:</p>
<pre><code class="language-scl">rel symbols = {s&quot;NAME&quot;, s&quot;AGE&quot;, s&quot;GENDER&quot;}
</code></pre>
<h3 id="datetime-and-duration"><a class="header" href="#datetime-and-duration">DateTime and Duration</a></h3>
<p><code>DateTime</code> and <code>Duration</code> are natively supported data structures by Scallop.
We commonly specify <code>DateTime</code> and <code>Duration</code> using their string form.
In the following example, we specify the <code>DateTime</code> values using the <code>t</code>-quoted-string notation (<code>t</code> represents time):</p>
<pre><code class="language-scl">rel event_dates = {(&quot;enroll&quot;, t&quot;2020-01-01&quot;), (&quot;finish&quot;, t&quot;2020-03-01&quot;)}
</code></pre>
<p>The dates will be all transformed into UTC time-zone.
When the date part is specified and the time is not specified, we will fill the time <code>00:00:00 UTC</code>.
When the time is specified but the date is not, we will use the current date when the program is invoked.
Any reasonable date-time format are acceptable, common ones include</p>
<ul>
<li><code>t&quot;2019-11-29 08:08:05-08&quot;</code></li>
<li><code>t&quot;4/8/2014 22:05&quot;</code></li>
<li><code>t&quot;September 17, 2012 10:09am&quot;</code></li>
<li><code>t&quot;2014/04/2 03:00:51&quot;</code></li>
<li><code>t&quot;2014年04月08日&quot;</code></li>
</ul>
<p><code>Duration</code>s can be specified using the <code>d</code>-quoted-string notation (<code>d</code> represents duration):</p>
<pre><code class="language-scl">rel event_durations = {(&quot;e1&quot;, d&quot;12 days&quot;), (&quot;e2&quot;, d&quot;15 days 20 seconds&quot;)}
</code></pre>
<p>The string can contain numbers followed by their units.
When specifying durations, the following units are accepted:</p>
<ul>
<li>nanoseconds (<code>n</code>)</li>
<li>microseconds (<code>usecs</code>)</li>
<li>milliseconds (<code>msecs</code>)</li>
<li>seconds (<code>secs</code>)</li>
<li>minutes (<code>m</code>)</li>
<li>hours (<code>h</code>)</li>
<li>days (<code>d</code>)</li>
<li>weeks (<code>w</code>)</li>
<li>months (<code>M</code>)</li>
<li>years (<code>y</code>)</li>
</ul>
<p>We can operate between <code>Duration</code> and <code>DateTime</code> using simple operations such as <code>+</code> and <code>-</code>:</p>
<ul>
<li><code>DateTime + Duration ==&gt; DateTime</code></li>
<li><code>Duration + Duration ==&gt; Duration</code></li>
<li><code>DateTime - DateTime ==&gt; Duration</code></li>
<li><code>DateTime - Duration ==&gt; DateTime</code></li>
<li><code>Duration - Duration ==&gt; Duration</code></li>
</ul>
<h3 id="entity"><a class="header" href="#entity">Entity</a></h3>
<p>Entity values are 64-bit unsigned integers created through hashing.
They are used to represent pointers of created entities.
They cannot be directly created.
Rather, they are managed by Scallop through the creation of entities.
For example,</p>
<pre><code class="language-scl">type List = Nil() | Cons(i32, List)
const MY_LIST = Cons(1, Cons(2, Nil()))
rel input_list(MY_LIST)
query input_list
</code></pre>
<p>The result is then</p>
<pre><code>input_list: {(entity(0x4cd0d9e6652cdfc7))}
</code></pre>
<p>Please refer to <a href="language/adt_and_entity.html">this section</a> for more informaiton on algebraic data types and entities.</p>
<h2 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h2>
<p>In Scallop, types can be converted using the <code>as</code> operator.
For example, we can have</p>
<pre><code class="language-scl">rel numbers = {1, 2, 3, 4, 5}
rel num_str(n as String) = numbers(n)
</code></pre>
<p>to derive the <code>numbers</code> to be <code>{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;}</code>.
In general, we can have all numbers castable to each other.
We also have every type being castable to <code>String</code>.
For converting <code>String</code> to other types, it undergoes a parsing process.
When the parsing does not go through, no result will be returned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-queries"><a class="header" href="#writing-queries">Writing Queries</a></h1>
<p>Consider the following example of classes, students, and enrollments, and that we want to compute the number of students who have enrolled in at least one CS class.</p>
<pre><code class="language-scl">// There are three classes
rel classes = {0, 1, 2}

// Each student is enrolled in a course (Math or CS)
rel enroll = {
  (&quot;tom&quot;, &quot;CS&quot;), (&quot;jenny&quot;, &quot;Math&quot;), // Class 0
  (&quot;alice&quot;, &quot;CS&quot;), (&quot;bob&quot;, &quot;CS&quot;), // Class 1
  (&quot;jerry&quot;, &quot;Math&quot;), (&quot;john&quot;, &quot;Math&quot;), // Class 2
}

// Count how many student enrolls in CS course
rel num_enroll_cs(n) = n := count(s: enroll(s, &quot;CS&quot;))
</code></pre>
<p>Normally, executing a program would result in <code>scli</code> outputting every single relation.</p>
<pre><code>classes: {(0), (1), (2)}
num_enroll_cs: {(3)}
enroll: {(&quot;alice&quot;, &quot;CS&quot;), (&quot;bob&quot;, &quot;CS&quot;), (&quot;jenny&quot;, &quot;Math&quot;), ...}
</code></pre>
<p>However, we might only be interested in the relation named <code>num_enroll_cs</code>.
In this case, we write a <em>query</em> using the <code>query</code> keyword:</p>
<pre><code class="language-scl">query num_enroll_cs
</code></pre>
<p>In this case, only the relation <code>num_enroll_cs</code> will be output:</p>
<pre><code>num_enroll_cs: {(3)}
</code></pre>
<h2 id="atomic-query"><a class="header" href="#atomic-query">Atomic Query</a></h2>
<p>One can also write atomic query if we just want to get a part of the relation.
For instance, consider the fibonacci example:</p>
<pre><code class="language-scl">type fib(x: i32, y: i32)
rel fib = {(0, 1), (1, 1)}
rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2) and x &lt;= 10
query fib(8, y) // fib(8, y): {(8, 34)}
</code></pre>
<p>In this case, we are just looking at the 8-th fibonacci number, which is 34.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-rules"><a class="header" href="#recursive-rules">Recursive Rules</a></h1>
<p>One very powerful programming construct with Scallop is to declaratively define recursion.
Inside of a rule, if a relational predicate appearing in the head appears in the body, the predicate is recursive.
For example, the definition of fibonacci number is recursive:</p>
<p>\[ \text{fib}(x) = \left\{ \begin{array}{ll} \text{fib}(x - 1) + \text{fib}(x - 2), &amp; \text{if}~ x &gt; 1 \\ 1, &amp; \text{otherwise} \end{array} \right. \]</p>
<p>Written in Scallop, we encode the function <code>fib</code> as a binary relation between the integer input and output:</p>
<pre><code class="language-scl">type fib(x: i32, y: i32)
</code></pre>
<p>We can define the base cases for \(\text{fib}(0)\) and \(\text{fib}(1)\):</p>
<pre><code class="language-scl">rel fib = {(0, 1), (1, 1)}
</code></pre>
<p>Now it comes to the definition of recursive cases, which peeks into \(\text{fib}(x - 1)\) and \(\text{fib}(x - 2)\) and sums them.</p>
<pre><code class="language-scl">rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2) // infinite-loop
</code></pre>
<p>However, when actually executing this, it would not terminate as we are attempting to compute all fibonacci numbers, and there are infinite amount of them.
In order to stop it, we can temporarily add a constraint to limit the value of <code>x</code>, so that we only compute the fibonacci number up to 10:</p>
<pre><code class="language-scl">rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2) and x &lt;= 10
</code></pre>
<p>At the end, we would get a the <code>fib</code> relation to contain the following facts:</p>
<pre><code>fib: {(0, 1), (1, 1), (2, 2), (3, 3), (4, 5), (5, 8), (6, 13), (7, 21), (8, 34), (9, 55), (10, 89)}
</code></pre>
<p>As suggested by the result, the 10-th fibonacci number is 89.</p>
<h2 id="case-study-graphs-and-transitive-closure"><a class="header" href="#case-study-graphs-and-transitive-closure">Case Study: Graphs and Transitive Closure</a></h2>
<p>Following is one of the most widely known Datalog program: computing the <code>path</code>s inside of a graph.
By definition, an edge or a sequence of edges constitute a path.
This is reflected by the following two rules:</p>
<pre><code class="language-scl">type edge(i32, i32)

rel path(a, b) = edge(a, b)
rel path(a, c) = path(a, b) and edge(b, c)
</code></pre>
<p>The first line states that an edge can form a path.
The second line states that a path, connected to a new edge, forms a new path.
As can be seen from the second line, the relation <code>path</code> appears in both the body and the head, making it a <em>recursive relation</em>.</p>
<p>In this example, suppose we have</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2)}
</code></pre>
<p>we would get the set of paths to be</p>
<pre><code>path: {(0, 1), (0, 2), (1, 2)}
</code></pre>
<p>Notice that the path <code>(0, 2)</code> is a compound path obtained from joining the two edges <code>(0, 1)</code> and <code>(1, 2)</code>.</p>
<h2 id="relation-dependency"><a class="header" href="#relation-dependency">Relation Dependency</a></h2>
<p>Given a rule with head and body, we say that the predicate appearing in the head <em>depends</em> on the predicates of the atoms appearing in the body.
This forms a dependency graph.
The above edge-path example would have the following dependency graph:</p>
<pre><code>edge &lt;--- path &lt;---+
            |      |
            +------+
</code></pre>
<p>The relation <code>edge</code> depends on nothing, while <code>path</code> depends on <code>edge</code> and also <code>path</code> itself.
This forms a loop in the dependency graph.
In general, if a program has a dependency graph with a loop, then the program requires <em>recursion</em>.
Any relation that is involved in a loop would be a <em>recursive relation</em>.</p>
<p>Notice that we are mostly talking about <em>positive dependency</em> here, as the atoms in the body of the rule are <em>positive atoms</em> (i.e., without annotation of negation or aggregation).
In more complex scenarios, there will be negation or aggregation in a rule, which we explain in detail in future sections.</p>
<h2 id="fixed-point-iteration"><a class="header" href="#fixed-point-iteration">Fixed-point Iteration</a></h2>
<p>The recursion in Scallop happens in <em>fixed-point iteration</em>.
In plain terms, the recursion will continue until there is no new fact being derived in an iteration.
In hind-sight, the whole Scallop program is executed in a loop.
Within one iteration, all of the rules inside of the program are executed.
Let us digest the actual execution happens when executing the above edge-path program:</p>
<pre><code class="language-scl">rel edge = {(0, 1), (1, 2), (2, 3)}
rel path(a, b) = edge(a, b)                 // rule 1
rel path(a, c) = path(a, b) and edge(b, c)  // rule 2
</code></pre>
<p>Before the first iteration, the <code>edge</code> has already been filled with 3 facts, namely <code>(0, 1)</code>, <code>(1, 2)</code>, and <code>(2, 3)</code>.
But the <code>path</code> is empty.
Let's now go through all the iterations:</p>
<pre><code>Iter 0: path = {}
Iter 1: path = {(0, 1), (1, 2), (2, 3)}
       Δpath = {(0, 1), (1, 2), (2, 3)} // through applying rule 1
Iter 2: path = {(0, 1), (1, 2), (2, 3), (0, 2), (1, 3)}
       Δpath = {(0, 2), (1, 3)}         // through applying rule 2
Iter 3: path = {(0, 1), (1, 2), (2, 3), (0, 2), (1, 3), (0, 3)}
       Δpath = {(0, 3)}                 // through applying rule 2
Iter 4: path = {(0, 1), (1, 2), (2, 3), (0, 2), (1, 3), (0, 3)}
       Δpath = {}
</code></pre>
<p>In the above note, we also include <code>Δpath</code>, which contains the new paths derived during the current iteration.
As can be seen, during iteration 1, paths of length 1 are derived; during iteration 2, paths of length 2 are derived.
During iteration 4, there is no more path to be derived, and therefore the <code>Δpath</code> is empty.
This tells us that no new facts are derived and the whole fixed-point iteration is stopped, giving us the final result.</p>
<h2 id="infinite-relations"><a class="header" href="#infinite-relations">Infinite Relations</a></h2>
<p>As we have described in the <em>fixed-point iteration</em>, the recursion will continue until no more fact is derived.
However, we are capable of writing rules that are infinite.
As shown in the first example:</p>
<pre><code class="language-scl">rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2)
</code></pre>
<p>gives you an infinite relation as there can always be a new <code>x</code> to be derived.
In this case, the fixed-point iteration never stops.</p>
<p>The root cause of this is Scallop's support for <em>value creationg</em>, i.e., the creation of new values.
Typically, database systems work in closed-world assumption, that is, all the items being reasoned about are already there.
No computation is done on arbitrarily created values.
But in the above example, we have derived <code>x</code> from the grounded expression <code>x - 1</code>, hence creating a new value.</p>
<p>Typically, the way to resolve this is to create bounds on the created values.
For example, the rule</p>
<pre><code class="language-scl">rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2) and x &lt;= 10
</code></pre>
<p>restricts that <code>x</code> cannot be greater than 10.
This makes the fixed-point iteration to stop after around 10 iterations.</p>
<p>Other way of getting around with this involve the use of <a href="https://dl.acm.org/doi/pdf/10.1145/6012.15399"><em>Magic-Set Transformations</em></a>, which we describe its equivalent in Scallop in <a href="language/magic_set.html">a later section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="negations"><a class="header" href="#negations">Negations</a></h1>
<p>Scallop supports negation to be attached to atoms to form negations.
In the following example, we are trying to obtain the set of people with no children:</p>
<pre><code class="language-scl">rel person = {&quot;bob&quot;, &quot;alice&quot;, &quot;christine&quot;} // There are three persons of interest
rel father = {(&quot;bob&quot;, &quot;alice&quot;)}            // Bob is Alice's father
rel mother = {(&quot;alice&quot;, &quot;christine&quot;)}      // Alice is Christine's mother

rel has_no_child(n) = person(n) and not father(n, _) and not mother(n, _)
</code></pre>
<p>The last rule basically says that if there is a person <code>n</code> who is neither anyone's father nor anyone's mother then the person <code>n</code> has no child.
This is indeed what we are going to obtain:</p>
<pre><code>has_no_child: {(&quot;christine&quot;,)}
</code></pre>
<p>It is clear that negations are very helpful in writing such kind of the rules.
However, there are many restrictions on negations.
We explain in detail such restrictions.</p>
<h2 id="negation-and-variable-grounding"><a class="header" href="#negation-and-variable-grounding">Negation and Variable Grounding</a></h2>
<p>If we look closely to the rule of <code>has_no_child</code> above, we will find that there is an atom <code>person(n)</code> being used in the body.
Why can't we remove it and just say &quot;if one is neither father nor mother then the one has no child&quot;?</p>
<pre><code class="language-scl">rel has_no_child(n) = not father(n, _) and not mother(n, _) // Error: variable `n` is not grounded
</code></pre>
<p>The problem is with variable grounding.
For the variable <code>n</code> to be appeared in the head, there is <strong>no positive atom</strong> that grounds it.
All we are saying are what <code>n</code> is not, but not what <code>n</code> is.
With only &quot;what it is not&quot;, it could be literally anything else in the world.</p>
<p>Therefore, we need to ground it with a positive atom such as <code>person(n)</code>.
With this rule, we have basically</p>
<h2 id="stratified-negation"><a class="header" href="#stratified-negation">Stratified Negation</a></h2>
<p>Expanding upon <a href="language/recursion.html#relation-dependency">our definition of dependency graph</a>,
if a predicate occurs in a negative atom in a body,
we say that the predicate of the rule head <em>negatively depends</em> on this predicate.
For example, the above <code>has_no_child</code> example has the following dependency graph.
Notice that we have marked the <em>positive</em> (<code>pos</code>) and <em>negative</em> (<code>neg</code>) on each edge:</p>
<pre><code>person &lt;--pos-- has_no_child --neg--&gt; father
                      |
                      +-----neg-----&gt; mother
</code></pre>
<p>Scallop supports <em>stratified negation</em>, which states that there is never a loop in the dependency graph which involves a negative dependency edge.
In other words, if there exists such a loop, the program will be rejected by the Scallop compiler.
Consider the following example:</p>
<pre><code class="language-scl">rel is_true() = not is_true() // Rejected
</code></pre>
<p>The relation <code>is_true</code> negatively depends on the relation <code>is_true</code> itself, making it a loop containing a negative dependency edge.
The error message would show that this program &quot;cannot be stratified&quot;.
If we draw the dependency graph of this program, it look like the following:</p>
<pre><code class="language-scl">is_true &lt;---+
   |        |
   +--neg---+
</code></pre>
<p>Since there is a loop (<code>is_true -&gt; is_true</code>) and the loop contains a negative edge, this program cannot be stratified.</p>
<p>The reason that stratified negation is named such way is that, if there is no negative dependency edge in a loop, the whole dependency can be decomposed in to <a href="https://en.wikipedia.org/wiki/Strongly_connected_component"><em>strongly connected components</em></a>, where inside of each strongly connected component (SCC), there is no negative dependency.
In other words, the negation has been <em>stratified</em>, so that the negative edge can only happen between SCCs.
We call each SCC a <em>stratum</em>, and the collection of them a <em>strata</em>.
Any non-recursive program has a dependency graph forming a <em>Directed Acyclic Graph</em> (DAG), and is therefore always stratifiable.</p>
<p>The following program, although containing both negation and recursion, can be stratified:</p>
<pre><code class="language-scl">rel path(a, b) = edge(a, b) and not sanitized(b)
rel path(a, c) = path(a, b) and edge(b, c) and not sanitized(b)
</code></pre>
<p>For it, the following dependency graph can be drawn:</p>
<pre><code>sanitized &lt;--neg-- path &lt;----+
                   |  |      |
     edge &lt;--pos---+  +--pos-+
</code></pre>
<p>In this program, we have three SCCs (or strata):</p>
<ul>
<li>Stratum 1: <code>{edge}</code></li>
<li>Stratum 2: <code>{sanitized}</code></li>
<li>Stratum 3: <code>{path}</code></li>
</ul>
<p>Negative dependency only occurs between stratum 2 and 3.
Therefore, the program can be accepted.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregations"><a class="header" href="#aggregations">Aggregations</a></h1>
<p>Aggregations in Scallop can be viewed as operations that aggregates over multiple facts.
Such operations include counting, summation and product, finding min and max, and logical quantifiers such as exists and forall.
Aggregations appear in the body of a rule, and can be nested for abbrevity.</p>
<p>As a concrete example, we look at a program which counts over a set of people:</p>
<pre><code class="language-scl">rel person = {&quot;alice&quot;, &quot;bob&quot;, &quot;christine&quot;}
rel num_people(n) = n := count(p: person(p)) // n = 3
</code></pre>
<!-- While further down the road we are going to discuss their probabilistic (multi-world) semantics, let's first view them as discrete logical operations. -->
<p>In general, we use the following syntax for aggregation formulas.</p>
<pre><code class="language-scl">R1, R2, ... := AGGREGATOR(V1, V2, ...: FORMULA (where U1, U2, ...: FORMULA)?)
</code></pre>
<p>We name <code>R1, ...</code> to be the aggregation <em>result</em> variable, <code>V1, ...</code> to be the <em>binding</em> variable, and the formula inside of the aggregation the <em>body</em>.
When the <code>where</code> keyword is used, we have the aggregation associated with <em>explicit group-by</em> clause.
Here, we call the set of variables <code>U1, ...</code> as <em>group-by variables</em>.
The formula under the <code>where</code> clause is named the <em>group-by body</em>.
The binding variables need to be fully grounded by the body formula, and the group-by variables (if presented) need to also be fully grounded by the group-by body.
For different types of aggregation, the <code>AGGREGATOR</code> might also change and annotated with different information.
The number of result variables, the number of binding variables, and their types differ for each aggregation.</p>
<p>Here is a high-level overview of each supported aggregator and their configurations.
In the table, <code>...</code> is used to denote an arbitrary amount of variables.</p>
<div class="table-wrapper"><table><thead><tr><th>Aggregator</th><th>Binding Variables</th><th>Result Variables</th></tr></thead><tbody>
<tr><td><code>count</code></td><td><code>Any...</code></td><td><code>usize</code></td></tr>
<tr><td><code>sum</code></td><td><code>Number</code></td><td>the same as the binding variable</td></tr>
<tr><td><code>prod</code></td><td><code>Number</code></td><td>the same as the binding variable</td></tr>
<tr><td><code>min</code></td><td><code>Any</code></td><td>the same as the binding variables</td></tr>
<tr><td><code>max</code></td><td><code>Any</code></td><td>the same as the binding variables</td></tr>
<tr><td><code>exists</code></td><td><code>Any...</code></td><td><code>bool</code></td></tr>
<tr><td><code>forall</code></td><td><code>Any...</code></td><td><code>bool</code></td></tr>
</tbody></table>
</div>
<p>Below, we elaborate on each aggregators and describe their usages.</p>
<h2 id="count"><a class="header" href="#count">Count</a></h2>
<p>To count the number of facts, we can use the <code>count</code> aggregator.
Just repeating the examples shown in the beginning:</p>
<pre><code class="language-scl">rel person = {&quot;alice&quot;, &quot;bob&quot;, &quot;christine&quot;}
rel num_people(n) = n := count(p: person(p)) // n = 3
</code></pre>
<p>We are counting the number of persons appear in the <code>person</code> relation.
To be more concrete, let's read out the aggregation formula:</p>
<blockquote>
<p>We count the number of <code>p</code> such that <code>p</code> is a <code>person</code>, and assign the result to the variable <code>n</code>.</p>
</blockquote>
<p>For <code>count</code>, there could be arbitrary (&gt; 0) number of binding variables which can be typed arbitrarily.
It will only have a single result variable which is typed <code>usize</code>.
For example, you may count the number of <code>edge</code>s:</p>
<pre><code class="language-scl">rel num_edges(n) = n := count(a, b: edge(a, b))
</code></pre>
<p>Here, we have two binding variables <code>a</code> and <code>b</code>, meaning that we are counting the number of <em>distinct</em> pairs of <code>a</code> and <code>b</code>.</p>
<p>Note that we can use the syntax sugar for aggregation to omit the repeated <code>n</code>:</p>
<pre><code class="language-scl">rel num_edges = count(a, b: edge(a, b))
</code></pre>
<h3 id="implicit-group-by"><a class="header" href="#implicit-group-by">Implicit Group-By</a></h3>
<p>With <code>group-by</code>, we may count the number of facts under a pre-defined group.
Consider the example where there is a scene with differet colored objects,</p>
<pre><code class="language-scl">rel obj_color = {(0, &quot;red&quot;), (1, &quot;red&quot;), (2, &quot;blue&quot;), (3, &quot;red&quot;)}
rel num_obj_per_color(col, num) = num := count(obj: obj_color(obj, col))
</code></pre>
<p>As suggested by the facts inside of <code>obj_color</code>, there are <code>4</code> objects indexed using <code>0, 1, 2, 3</code>, each associated with a different color.
The object #0, #1, and #3 are <code>red</code> and the object #2 is <code>blue</code>.
Therefore, we will get 3 red objects and 1 blue object, as computed in the result of <code>num_obj_per_color</code>:</p>
<pre><code>num_obj_per_color: {(&quot;blue&quot;, 1), (&quot;red&quot;, 3)}
</code></pre>
<p>Let's analyze the rule in detail.
We find that we are counting over <code>obj</code> such that the object <code>obj</code> has a certain color <code>col</code>.
But <code>col</code> is also a variable occurring in the head of the rule.
This is an <em>implicit group-by</em>, in that the variable <code>col</code> is being used as an implicit group-by variable.
That is, we are conditioning the counting procedure under each <em>group</em> that is defined by the <code>col</code> variable.
Since there are two colors appearing in the <code>obj_color</code> relation, we are performing count for each of the two groups.</p>
<p>In general, if a variable is positively grounded in the body and appear in the head of a parent rule, we call the variable an <em>implicit group-by variable</em>.</p>
<h3 id="explicit-group-by"><a class="header" href="#explicit-group-by">Explicit Group-By</a></h3>
<p>In the above example, there is no green colored object.
However, how do we know that the number of green object is 0?
The result does not seem to address this problem.</p>
<p>The missing piece is a <em>domain</em> of the possible groups.
Without explicitly setting the domain, Scallop could only search inside of the database on possible groups.
However, we can explicitly tell Scallop about what are the groups.
Consider the following rewrite of the above program:</p>
<pre><code class="language-scl">rel colors = {&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;}
rel obj_color = {(0, &quot;red&quot;), (1, &quot;red&quot;), (2, &quot;blue&quot;), (3, &quot;red&quot;)}
rel num_obj_per_color(col, num) = num := count(obj: obj_color(obj, col) where col: colors(col))
</code></pre>
<p>With the <code>where</code> clause, we have explicitly declared that <code>col</code> is a <em>group-by variable</em> which is grounded by the <code>colors</code> relation.
If we look into the <code>colors</code> relation, we find that there are three possible colors that we care about, red, green, and blue.
In this case, we will consider <code>&quot;green&quot;</code> as the third group and try to count the number of green objects -- which there are 0:</p>
<pre><code>num_obj_per_color: {(&quot;blue&quot;, 1), (&quot;green&quot;, 0), (&quot;red&quot;, 3)}
</code></pre>
<h2 id="sum-and-product"><a class="header" href="#sum-and-product">Sum and Product</a></h2>
<p>We can use the aggregator of sum and product to aggregate multiple numerical values.
Consider the following example of sales:</p>
<pre><code class="language-scl">rel sales = {(&quot;alice&quot;, 1000.0), (&quot;bob&quot;, 1200.0), (&quot;christine&quot;, 1000.0)}
</code></pre>
<p>We can compute the sum of all the sales:</p>
<pre><code class="language-scl">rel total_sales(s) = s := sum[p](sp: sales(p, sp)) // 3200.0
// or
rel total_sales = sum[p](sp: sales(p, sp)) // 3200.0
</code></pre>
<p>Notice that the result type of <code>s</code> is the same as the type of the binding variable <code>sp</code>, which is <code>f32</code> as indicated by the decimals in the definition of <code>sales</code>.
Here, the argument variable <code>p</code> is necessary since it is the key to index each sale number.
The above rule body is equivalent to the following math formula:</p>
<p>\[ s = \sum_p \text{sale}_p \]</p>
<p>If we do not use the argument variable, we get the following:</p>
<pre><code class="language-scl">rel total_sales_wrong(s) = s := sum(sp: sales(p, sp)) // 2200.0, since the two 1000.0 will be deduplicated without its key
</code></pre>
<p>The product aggregator <code>prod</code> can be used in a similar manner as <code>sum</code>.</p>
<h2 id="min-max-argmin-and-argmax"><a class="header" href="#min-max-argmin-and-argmax">Min, Max, Argmin, and Argmax</a></h2>
<p>Scallop can compute the minimum or maximum among a set of values.
In the following example, we find the maximum grade of an exam:</p>
<pre><code class="language-scl">rel exam_grades = {(&quot;a&quot;, 95.2), (&quot;b&quot;, 87.3), (&quot;c&quot;, 99.9)}
rel min_score(m) = m := max(s: exam_grades(_, s)) // 99.9
// or, succinctly
rel min_score = max(s: exam_grades(_, s)) // 99.9
</code></pre>
<p>The number (and types) of binding variables can be arbitrary, but the result variables must match the binding variables.
In the above case, since <code>s</code> is of type <code>f32</code>, <code>m</code> will be of type <code>f32</code> as well.</p>
<p>It is also possible to get argmax/argmin.
Suppose we want to get the person (along with their grade) who scored the best, we write:</p>
<pre><code class="language-scl">rel best_student(n, s) = (n, s) := max[n](s: exam_grades(n, s))
// or, succinctly
rel best_student = max[n](s: exam_grades(n, s))
</code></pre>
<p>Here, we are still finding the maximum score <code>s</code>, but along with <code>max</code> we have specified the &quot;arg&quot; (<code>[n]</code>) which associates with the maximum score.
We call <code>n</code> an arg variable for <code>min</code>/<code>max</code> aggregator.
The arg variable is grounded by the aggregation body, and can be directly used in the head of the rule.</p>
<p>If we do not care about the grade and just want to know who has the best grade, we can use wildcard <code>_</code> to ignore the result variable, like</p>
<pre><code class="language-scl">rel best_student(n) = (n, _) := max[n](s: exam_grades(n, s))
</code></pre>
<p>Alternatively, we can also use <code>argmax</code>:</p>
<pre><code class="language-scl">rel best_student(n) = n := argmax[n](s: exam_grades(n, s))
// or, succinctly
rel best_student = argmax[n](s: exam_grades(n, s))
</code></pre>
<h2 id="exists-and-forall"><a class="header" href="#exists-and-forall">Exists and Forall</a></h2>
<p>Logical quantifier such as exists and forall can also be encoded as aggregations.
They will return value of boolean as the aggregation result.</p>
<h3 id="existential-quantifier"><a class="header" href="#existential-quantifier">Existential Quantifier</a></h3>
<p>Let us start with discussing the easier of the two, <code>exists</code>.
Technically, all variables in the body of Scallop rule are existentially quantified.
We can use <code>exists</code> aggregation to make it explicit.
For example, we can check if there exists an object that is blue:</p>
<pre><code class="language-scl">rel obj_color = {(0, &quot;red&quot;), (1, &quot;green&quot;)}
rel has_blue(b) = b := exists(o: obj_color(o, &quot;blue&quot;))
</code></pre>
<p>Specifically, we are checking &quot;if there exists an object <code>o</code> such that its color is <code>blue</code>&quot;.
The result is being assigned to a variable <code>b</code>.
Since there is no blue object, we will get a result of <code>has_blue(false)</code>.</p>
<p>In case when we just want the result boolean to be <code>true</code> or <code>false</code>, we can omit the result variables.
For example, we can rewrite the recursive case of edge-path transitive closure as</p>
<pre><code class="language-scl">rel path(a, c) = exists(b: path(a, b) and edge(b, c))
</code></pre>
<p>We note that this is just a syntax sugar equivalent to the following:</p>
<pre><code class="language-scl">rel path(a, c) = r := exists(b: path(a, b) and edge(b, c)) and r == true
</code></pre>
<p>When we want to know the inexistence of something, we can do</p>
<pre><code class="language-scl">rel no_red() = not exists(o: obj_color(o, &quot;red&quot;))
</code></pre>
<p>Note that there can be arbitrary amount of binding variables.</p>
<h3 id="universal-quantifier"><a class="header" href="#universal-quantifier">Universal Quantifier</a></h3>
<p>We can also have universal quantifier <code>forall</code>.
For this, there is a special requirement for universal quantification: the body formula has to be an <code>implies</code> (<code>=&gt;</code>) formula.
This restriction is enforced so that all the binding variables have bounds being specified on the left-hand-side of the <code>implies</code> formula.
In the following example, we check if all the objects are spherical:</p>
<pre><code class="language-scl">type Shape = CUBE | SPHERE | CONE | CYLINDER
rel object = {0, 1, 2}
rel obj_shape = {(0, CUBE), (1, SPHERE), (2, SPHERE)}
rel target(b) = b := forall(o: object(o) implies obj_shape(o, SPHERE))
</code></pre>
<p>Notice that we have a relation which defines the domain of <code>object</code>, suggesting that there are just 3 objects for us to work with.
In the aggregation, we are checking &quot;for all <code>o</code> such that <code>o</code> is an object, is the object a sphere?&quot;
The result is stored in the variable <code>b</code> and propagated to the <code>target</code> relation.</p>
<p>The reason we need to have an <em>implies</em> formula is that we need to use the left-hand-side of <code>implies</code> to give bounds to the universally quantified variables.
Scallop cannot reason about open domain variables.</p>
<p>Note that similar to <code>exists</code>, we can also remove the result variable.
The following program derives a boolean (arity-0) relation <code>target</code> denoting whether all the red objects are cubes:</p>
<pre><code class="language-scl">type Shape = CUBE | SPHERE | CONE | CYLINDER
type Color = RED | GREEN | BLUE
rel obj_shape = {(0, CUBE), (1, SPHERE), (2, SPHERE)}
rel obj_color = {(0, RED),  (1, GREEN),  (2, GREEN)}
rel target() = forall(o: obj_color(o, RED) implies obj_shape(o, CUBE)) // {()}
</code></pre>
<p>Here, we directly use <code>obj_color</code> to serve as the left-hand-side of the <code>implies</code>.
There will be one empty tuple being derived, suggesting that the statement is true.</p>
<h2 id="string-join"><a class="header" href="#string-join">String Join</a></h2>
<p>If you have multiple facts containing strings and you want to join them together, you can use the <code>string_join</code> aggregator:</p>
<pre><code class="language-scl">rel R = {&quot;hello&quot;, &quot;world&quot;}
rel P1(n) = n := string_join(s: R(s)) // P1(&quot;helloworld&quot;)
rel P2(n) = n := string_join&lt;&quot; &quot;&gt;(s: R(s)) // P2(&quot;hello world&quot;)
</code></pre>
<p>In the above example,
we can either directly join, producing the string &quot;helloworld&quot;,
or join with separator <code>&quot; &quot;</code>, producing the string &quot;hello world&quot;.
Note that the order of the strings in the joined string is determined by the strings.
Here, <code>&quot;hello&quot;</code> starts with <code>&quot;h&quot;</code>, which is smaller than the <code>&quot;w&quot;</code> in <code>&quot;world&quot;</code>, therefore occurring before <code>&quot;world&quot;</code>.
If you want to specify an explicit order, use the argument variable:</p>
<pre><code class="language-scl">rel R = {(2, &quot;hello&quot;), (1, &quot;world&quot;)}
rel P(n) = n := string_join&lt;&quot; &quot;&gt;[i](s: R(i, s)) // P(&quot;world hello&quot;)
</code></pre>
<p>Since we have specified the variable <code>i</code> to be the argument of <code>string_join</code>, it serves to order the tuples.
Here, we have <code>(1, &quot;world&quot;)</code> and <code>(2, &quot;hello&quot;)</code>, so the joined string will be <code>&quot;world hello&quot;</code> instead of <code>&quot;hello world&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-constants"><a class="header" href="#declaring-constants">Declaring Constants</a></h1>
<p>We can declare constants and give it names.
The general syntax is the following:</p>
<pre><code class="language-scl">const NAME (: TYPE)? = CONSTANT
</code></pre>
<p>For example, we can define the value of <code>PI</code>:</p>
<pre><code class="language-scl">const PI = 3.1415926
</code></pre>
<p>Notice that here we have not specified the type of <code>PI</code>.
By default, a float value would resort to the place where the constant is used.
If we want to specify a non-default type, we can do</p>
<pre><code class="language-scl">const PI: f64 = 3.1415926
</code></pre>
<p>We can also declare multiple constants at a time:</p>
<pre><code class="language-scl">const LEFT = 0, UP = 1, RIGHT = 2, DOWN = 3
</code></pre>
<h2 id="enum-types"><a class="header" href="#enum-types">Enum Types</a></h2>
<p>We sometimes want to define enum types which contain constant variables.
Common examples include <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> under the <code>Color</code> type, and <code>LEFT</code>, <code>RIGHT</code>, <code>UP</code> under the <code>Action</code> type.
These can be achieved by defining enum types:</p>
<pre><code class="language-scl">type Color = RED | GREEN | BLUE
type Action = LEFT | UP | RIGHT | DOWN
</code></pre>
<p>Internally, the values such as <code>RED</code> and <code>UP</code> are unsigned integer constants.
If not specified, the values start from 0 and goes up 1 at a time.</p>
<p>For example, given the type definition above, <code>RED = 0</code>, <code>GREEN = 1</code>, and <code>BLUE = 2</code>.
For <code>Action</code>s, <code>LEFT = 0</code>, <code>UP = 1</code>, and etc.
Notice that even when <code>Color</code> and <code>Action</code> are different types, their values can overlap.</p>
<p>One can specify the values of these enum variants by attaching actual numbers to them.
In the following example, we have explicitly assigned three values to the colors.</p>
<pre><code class="language-scl">type Color = RED = 3 | GREEN = 5 | BLUE = 7
</code></pre>
<p>We can also just set a few of those:</p>
<pre><code class="language-scl">type Color = RED | GREEN = 10 | BLUE
</code></pre>
<p>In this case, <code>RED = 0</code>, <code>GREEN = 10</code>, and <code>BLUE = 11</code>.
Notice how blue's value is incremented from <code>GREEN</code>.</p>
<h2 id="displaying-constants"><a class="header" href="#displaying-constants">Displaying Constants</a></h2>
<p>Constants are just values and many of them are integer values.
They are not explicitly associated with any symbols.
If you want to display them correctly, we advise you create auxilliary relations storing the mapping from each constant to its string form.
For example, we can have</p>
<pre><code class="language-scl">rel color_to_string = {(RED, &quot;red&quot;), (GREEN, &quot;green&quot;), (BLUE, &quot;blue&quot;)}
</code></pre>
<p>In this case, following the result with <code>color_to_string</code> relation will display their desired meanings properly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algebraic-data-type-and-entities"><a class="header" href="#algebraic-data-type-and-entities">Algebraic Data Type and Entities</a></h1>
<p>Algebraic data types are powerful programming constructs that allows user to define custom data structures and variants.
Consider a traditional functional definition of a <code>List</code>:</p>
<pre><code class="language-scl">type IntList = Nil()
             | Cons(i32, List)
</code></pre>
<p>We are saying that a <code>IntList</code> can be one of two variants, <code>Nil</code> and <code>Cons</code>:</p>
<ul>
<li><code>Nil</code> denotes the end of a list;</li>
<li><code>Cons</code> contains the current <code>i32</code> integer and a continuation of the list.</li>
</ul>
<p>In this representation, we can represent a list like <code>[1, 2, 3]</code> with <code>Cons(1, Cons(2, Cons(3, Nil())))</code>.
This is indeed what we can write in Scallop.
We can declare such a list as a constant:</p>
<pre><code class="language-scl">const MY_LIST = Cons(1, Cons(2, Cons(3, Nil())))
</code></pre>
<p>In general, we call the type definition of such data structure <em>Algebraic Data Type</em> definitions, or <em>ADT</em> definitions.
The name <em>Entity</em> is used to refer to objects of such data types.
In the example above, the constant <code>MY_LIST</code> is an <em>entity</em> of the <em>ADT</em> named <code>IntList</code>.</p>
<p>In this section, we describe in detail the definition and use of ADT and Entities.
We also touch on the internals.</p>
<h2 id="defining-algebraic-data-types-adt"><a class="header" href="#defining-algebraic-data-types-adt">Defining Algebraic Data Types (ADT)</a></h2>
<p>We use the following syntax to define ADTs:</p>
<pre><code class="language-scl">type TYPE_NAME = VARIANT_NAME(ARG_TYPE_1, ARG_TYPE_2, ...) | ...
</code></pre>
<p>An ADT named <code>TYPE_NAME</code> is defined to have multiple (at least 2) named variants with <code>VARIANT_NAME</code>.
Each variant holds a tuple of values typed by <code>ARG_TYPE_1</code>, <code>ARG_TYPE_2</code>, etc.
We call variants that have no argument <em>terminal variant</em>s.
Parenthesis are still needed for those variants.</p>
<p>Please note that there cannot be duplicated variant names, either within the same ADT or different ADTs.
For example, the following code would result in compilation failure:</p>
<pre><code class="language-scl">type IntList  = Cons(i32, IntList)   | Nil()
type BoolList = Cons(bool, BoolList) | Nil() // Failure: Cons and Nil are already defined
</code></pre>
<p>Currently, ADTs do not support generics.
In the above case, the <code>IntList</code> and <code>BoolList</code> needs to be defined separately with differently named variants.</p>
<h3 id="using-adt-to-represent-arithmetic-expressions"><a class="header" href="#using-adt-to-represent-arithmetic-expressions">Using ADT to represent arithmetic expressions</a></h3>
<p>Common data that can be expressed through ADT could be structured expressions.
The following definition describes the abstract syntax tree (AST) of simple arithmetic expressions:</p>
<pre><code class="language-scl">type Expr = Int(i32)        // An expression could be a simple integer,
          | Add(Expr, Expr) // a summation of two expressions
          | Sub(Expr, Expr) // a substraction of two expressions
</code></pre>
<p>The following code encodes a simple expression</p>
<pre><code class="language-scl">// The expression (1 + 3) - 5
const MY_EXPR = Sub(Add(Int(1), Int(3)), Int(5))
</code></pre>
<h3 id="using-adt-to-represent-data-structures"><a class="header" href="#using-adt-to-represent-data-structures">Using ADT to represent data structures</a></h3>
<p>Data structures such as binary trees can also be represented:</p>
<pre><code class="language-scl">type Tree = Node(i32, Tree, Tree) | Nil()
</code></pre>
<p>Here, <code>Node(i32, Tree, Tree)</code> represents a node in a tree holding three things:
an integer (<code>i32</code>), a left sub-tree <code>Tree</code>, and a right sub-tree <code>Tree</code>.
The other variant <code>Nil</code> represents an empty sub-tree.
In this encoding, <code>Node(5, Nil(), Nil())</code> would be representing a leaf-node holding a number 5.</p>
<p>The following code encodes a balanced binary search tree:</p>
<pre><code class="language-scl">//         3
//      /     \
//    1         5
//  /   \     /   \
// 0     2   4     6
const MY_TREE =
  Node(3,
    Node(1,
      Node(0, Nil(), Nil()),
      Node(2, Nil(), Nil()),
    ),
    Node(5,
      Node(4, Nil(), Nil()),
      Node(6, Nil(), Nil()),
    )
  )
</code></pre>
<h2 id="working-with-entities"><a class="header" href="#working-with-entities">Working with Entities</a></h2>
<p>Entities are most commonly created as constants using the <code>const</code> keyword.
Let us revisit the <code>List</code> example and see how we can use the defined constant in our analysis.</p>
<pre><code class="language-scl">type List = Cons(i32, List) | Nil()

const MY_LIST = Cons(1, Cons(2, Cons(3, Nil()))) // [1, 2, 3]
</code></pre>
<h3 id="using-entities-in-relations"><a class="header" href="#using-entities-in-relations">Using Entities in Relations</a></h3>
<p>We can include the constant entities as part of a fact:</p>
<pre><code class="language-scl">rel target(MY_LIST)
query target
</code></pre>
<p>As a result of the above program, we are going to get the value of the entity <code>MY_LIST</code>:</p>
<pre><code>target: {(entity(0xff08d5d60a201f17))}
</code></pre>
<p>The value is going to be a 64-bit integer encoded in hex.
It is a unique identifier for the created entity.</p>
<p>Note that, identical entities are going to have the same identifier.
In the following example, <code>MY_LIST_1</code> and <code>MY_LIST_2</code> are identical, and therefore their hex identifier are the same.</p>
<pre><code class="language-scl">const MY_LIST_1 = Cons(1, Nil()),
      MY_LIST_2 = Cons(1, Nil()),
      MY_LIST_3 = Cons(2, Nil())

rel lists = {
  (1, MY_LIST_1),
  (2, MY_LIST_2),
  (3, MY_LIST_3),
}

query lists
// lists: {
//   (1, entity(0x678defa0a65c83ab)), // Notice that the entity 1 and 2 are the same
//   (2, entity(0x678defa0a65c83ab)),
//   (3, entity(0x3734567c3d9f8d3f)), // This one is different than above
// }
</code></pre>
<h3 id="decomposing-entities-in-rules"><a class="header" href="#decomposing-entities-in-rules">Decomposing Entities in Rules</a></h3>
<p>To peek into the content of an Entity, we can <em>destruct</em> it using the <code>case</code>-<code>is</code> operator.
We look at an example of computing the length of a list:</p>
<pre><code class="language-scl">type length(list: List, len: i32)
rel length(list, 0)     = case list is Nil()
rel length(list, l + 1) = case list is Cons(_, tl) and length(tl, l)
</code></pre>
<p>We define a recursive relation <code>length</code> to compute the length of a list.
There are two cases.
When the list is <code>Nil()</code>, this means the list has already ended.
Therefore the list has a length of <code>0</code>
For the second case, the list is <code>Cons(_, tl)</code>.
Here, the length of list is the length of <code>tl</code> plus 1.</p>
<p>We can then compute the length of a list by <code>query</code>ing the <code>length</code> relationship on a constant list.</p>
<pre><code class="language-scl">query length(MY_LIST, l) // l = 3
</code></pre>
<h3 id="case-study-decomposing-entities-for-pretty-printing"><a class="header" href="#case-study-decomposing-entities-for-pretty-printing">Case Study: Decomposing Entities for Pretty-Printing</a></h3>
<p>We can look at more examples of using the <code>case</code>-<code>is</code> operators.
The following set of rules pretty-prints expressions:</p>
<pre><code class="language-scl">type Expr = Int(i32) | Add(Expr, Expr) | Sub(Expr, Expr)

type to_string(expr: Expr, str: String)
rel to_string(e, $format(&quot;{}&quot;, i))           = case e is Int(i)
rel to_string(e, $format(&quot;({} + {})&quot;, a, b)) = case e is Add(e1, e2) and to_string(e1, a) and to_string(e2, b)
rel to_string(e, $format(&quot;({} - {})&quot;, a, b)) = case e is Sub(e1, e2) and to_string(e1, a) and to_string(e2, b)
</code></pre>
<p>Shown in the example, we have written three <code>to_string</code> rules for pretty-printing the <code>Expr</code> data structure.
Each rule correspond to handling exactly one of the variants.
For the inductive cases <code>Add</code> and <code>Sub</code>, we have the <code>to_string</code> rule defined recursively so that the sub-expressions are also converted to strings.
For pretty-printing, we have used the <code>$format</code> foreign function.</p>
<p>At the end, running the following snippet</p>
<pre><code class="language-scl">const MY_EXPR = Sub(Add(Int(3), Int(5)), Int(1))
query to_string(MY_EXPR, s)
</code></pre>
<p>would give the following result, suggesting that the pretty-printed expression is <code>((3 + 5) - 1)</code></p>
<pre><code>to_string(MY_EXPR, s): {(entity(0xa97605c2703c6249), &quot;((3 + 5) - 1)&quot;)}
</code></pre>
<h3 id="case-study-checking-regular-expressions"><a class="header" href="#case-study-checking-regular-expressions">Case Study: Checking Regular Expressions</a></h3>
<p>With ADT, we can specify the language of regular expressions (regex) with ease.
Let's consider a very simple regex with union (<code>|</code>) and star (<code>*</code>), while phrases can be grouped together.
For example, the regex <code>&quot;a*b&quot;</code> expresses that character <code>a</code> can be repeated arbitrary amount of time (including 0-times), followed by a single <code>b</code>.
This regex can be used to match strings like <code>&quot;aaaab&quot;</code> and <code>&quot;b&quot;</code>, but not <code>&quot;ba&quot;</code>.</p>
<p>Let's try to define this regex language in Scallop!</p>
<pre><code class="language-scl">type Regex = Char(char)           // a single character
           | Star(Regex)          // the star of a regex
           | Union(Regex, Regex)  // a union of two regexes
           | Concat(Regex, Regex) // concatenation of two regexes
</code></pre>
<p>As can be seen, we have defined 4 variants of this regex language.
With this, our regex <code>&quot;a*b&quot;</code> can be expressed as follows:</p>
<pre><code class="language-scl">// a*b
const A_STAR_B = Concat(Star(Char('a')), Char('b'))
</code></pre>
<p>Now, let's define the actual semantics of this regex language and write a relation <code>matches</code> to check if the regex matches with a given sub-string.
We first setup the types of such relations.</p>
<ul>
<li><code>input_regex</code> is a unary-relation for holding the regex to be checked against;</li>
<li><code>input_string</code> is a unary-relation for holding the string to be checked against;</li>
<li><code>matches_substr</code> is for checking if a sub-regex <code>r</code> can be matched with the input string between <code>begin</code> and <code>end</code> indices, where <code>end</code> is exclusive;</li>
<li><code>matches</code> is a boolean relation telling whether the <code>A_STAR_B</code> regex matches with the input string or not.</li>
</ul>
<pre><code class="language-scl">type input_regex(r: Regex)
type input_string(s: String)
type matches_substr(r: Regex, begin: usize, end: usize)
type matches()
</code></pre>
<p>The main bulk of the code will then be dedicated to define the <code>matches_substr</code> relation.
At a high level, we decompose on each type of regex, and match on sub-strings.
The first rule that we are going to write would be for the <code>Char</code> variant.</p>
<pre><code class="language-scl">rel matches_substr(r, i, i + 1) = case r is Char(c) and input_string(s) and string_chars(s, i, c)
</code></pre>
<p>The rule suggests that if the regex <code>r</code> is a single character <code>c</code>, then we go into the input string <code>s</code> and find all the index <code>i</code> such that its corresponding character is <code>c</code>.
The matched sub-string would start at index <code>i</code> and end at index <code>i + 1</code>.
Note that the <code>string_chars</code> relation is a foreign predicate that decomposes the string into characters.</p>
<p>Similarly, we can write the rules for other variants:</p>
<pre><code class="language-scl">// For star; it matches empty sub-strings [i, i) and recursively on sub-regex
rel matches_substr(r, i, i) = case r is Star(_) and input_string(s) and string_chars(s, i, _)
rel matches_substr(r, b, e) = case r is Star(r1) and matches_substr(r, b, c) and matches_substr(r1, c, e)

// For union; any string that matches left or right sub-regex would match the union
rel matches_substr(r, b, e) = case r is Union(r1, r2) and matches_substr(r1, b, e)
rel matches_substr(r, b, e) = case r is Union(r1, r2) and matches_substr(r2, b, e)

// For concat; we need strings to match in a consecutive matter
rel matches_substr(r, b, e) = case r is Concat(r1, r2) and matches_substr(r1, b, c) and matches_substr(r2, c, e)
</code></pre>
<p>Lastly, we add the rule to derive the final <code>matches</code> relation.
Basically, it checks if the regex matches the start-to-end of the input string</p>
<pre><code class="language-scl">rel matches() = input_regex(r) and input_string(s) and matches_substr(r, 0, $string_length(s))
</code></pre>
<p>Let us test the result!</p>
<pre><code class="language-scl">rel input_regex(A_STAR_B)
rel input_string(&quot;aaaab&quot;)
query matches // {()}
</code></pre>
<h2 id="dynamically-creating-entities"><a class="header" href="#dynamically-creating-entities">Dynamically Creating Entities</a></h2>
<p>There are cases where we want to create new entities during the deductive process.
This is done through the <code>new</code> keyword followed by the entity to create.
Suppose we have the definition of <code>List</code> and some pretty-printing code for it:</p>
<pre><code class="language-scl">type List = Cons(i32, List) | Nil()

rel to_string_2(l, &quot;]&quot;)                      = case l is Nil()
rel to_string_2(l, $format(&quot;{}]&quot;, i))        = case l is Cons(i, Nil())
rel to_string_2(l, $format(&quot;{}, {}&quot;, i, ts)) = case l is Cons(i, tl) and case tl is Cons(_, _) and to_string_2(tl, ts)
rel to_string(l, $format(&quot;[{}&quot;, tl))         = to_string_2(l, tl)
</code></pre>
<p>The following example shows that, given an input list <code>l</code>, we generate a result list <code>Cons(1, l)</code>.</p>
<pre><code class="language-scl">type input_list(List)
rel result_list(new Cons(1, l)) = input_list(l)
</code></pre>
<p>Given an actual list defined as a constant, we will be able to specify that the constant is the input list:</p>
<pre><code class="language-scl">const MY_INPUT_LIST = Cons(2, Cons(3, Nil()))
rel input_list(MY_INPUT_LIST)
</code></pre>
<p>Now, let's visualize the results!</p>
<pre><code class="language-scl">rel input_list_str(s) = to_string(MY_INPUT_LIST, s)
rel result_list_str(s) = result_list(l) and to_string(l, s)

query input_list_str  // [2, 3]
query result_list_str // [1, 2, 3]
</code></pre>
<p>As can be seen, through the <code>new</code> operator, we have essentially created a new list containing the element <code>1</code>.
We note that the rule for <code>result_list</code> is <em>not</em> recursive.
In general, extra care needs to be taken to ensure that the program does not go into infinite loop.`</p>
<h3 id="case-study-creating-entities-for-equality-saturation"><a class="header" href="#case-study-creating-entities-for-equality-saturation">Case Study: Creating Entities for Equality Saturation</a></h3>
<p>In this case study we look at the problem of equality saturation.
Given an symbolic expression, there might be ways to simplify it, which are defined through <em>rewrite rules</em>.
Notice that after simplification, the program should be equivalent to the input.
The problem is challenging as there might be multiple ways to apply the rewrite rules.
How do we then systematically derive the simplest equivalent program?</p>
<p>A simple example here is the symbolic arithmetic expression language, with constant, variables, and summation rule:</p>
<pre><code class="language-scl">type Expr = Const(i32) | Var(String) | Add(Expr, Expr)
</code></pre>
<p>One example expression that we can express in this language would be</p>
<pre><code class="language-scl">const MY_EXPR = Add(Add(Const(-3), Var(&quot;a&quot;)), Const(3)) // (-3 + a) + 3
</code></pre>
<p>For visualization, we write a <code>to_string</code> function</p>
<pre><code class="language-scl">rel to_string(p, i as String) = case p is Const(i)
rel to_string(p, v)           = case p is Var(v)
rel to_string(p, $format(&quot;({} + {})&quot;, s1, s2)) =
  case p is Add(p1, p2) and to_string(p1, s1) and to_string(p2, s2)
</code></pre>
<p>If we query on <code>to_string</code> for <code>MY_EXPR</code>, we would get</p>
<pre><code class="language-scl">query to_string(MY_EXPR, s) // s = &quot;((-3 + a) + 3)&quot;
</code></pre>
<p>Now let us deal with the actual simplification.
The expression <code>(-3 + a) + 3</code> could be simplified to just <code>a</code>, as the <code>-3</code> and <code>3</code> cancels out.
The way to do the simplification is to write two things:</p>
<ol>
<li>rewrite rules in the form of equivalence relation;</li>
<li>the weight function giving each expression a weight to tell which expression is <em>simpler</em>.</li>
</ol>
<p>For this, the following set of relations needs to be defined.</p>
<pre><code class="language-scl">type input_expr(expr: Expr)
type equivalent(expr_1: Expr, expr_2: Expr)
type weight(expr: Expr, w: i32)
type simplest(expr: Expr)
</code></pre>
<p>Note that we need set a prior knowledge on <code>equivalent</code>: the <code>expr_1</code> is always <em>more complex</em> than the <code>expr_2</code>.
This is to prevent the simplification to go to arbitrary direction and result in infinite-loop.
In such case, <code>equivalent</code> would not be commutative.
Let us start with <code>equivalent</code> and define its basic property of identity and transitivity:</p>
<pre><code class="language-scl">// Identity
rel equivalent(e, e) = case e is Const(_) or case e is Var(_) or case e is Add(_, _)

// Transitivity
rel equivalent(e1, e3) = equivalent(e1, e2) and equivalent(e2, e3)
</code></pre>
<p>Now, we can write the rewrite rules.
The first one we are going to write states that, if <code>e1</code> and <code>e1p</code> are equivalent and <code>e2</code> and <code>e2p</code> are equivalent,
their additions (<code>Add(e1, e2)</code> and <code>Add(e1p, e2p)</code>) are equivalent too.</p>
<pre><code class="language-scl">// e1 == e1p, e2 == e2p ==&gt; (e1 + e2) == (e1p + e2p)
rel equivalent(e, new Add(e1p, e2p)) = case e is Add(e1, e2) and equivalent(e1, e1p) and equivalent(e2, e2p)
</code></pre>
<p>The next rule states that Addition is commutative, such that <code>Add(a, b)</code> is equivalent to <code>Add(b, a)</code>:</p>
<pre><code class="language-scl">// (a + b) == (b + a)
rel equivalent(e, new Add(b, a)) = case e is Add(a, b)
</code></pre>
<p>We also have a rule for associativity:</p>
<pre><code class="language-scl">// (a + (b + c)) == ((a + b) + c)
rel equivalent(e, new Add(new Add(a, b), c)) = case e is Add(a, Add(b, c))
</code></pre>
<p>A rule for simplifying adding summation identity 0:</p>
<pre><code class="language-scl">// a + 0 = a
rel equivalent(e, a) = case e is Add(a, Const(0))
</code></pre>
<p>A rule for reducing two constants addition:</p>
<pre><code class="language-scl">rel equivalent(e, Const(a + b)) = case e is Add(Const(a), Const(b))
</code></pre>
<p>Now we have 5 rewrite-rules in place, let us define how to compute the weight of each expression.
The leaf nodes (<code>Var</code> and <code>Const</code>) have weight of <code>1</code>, and the addition have the weight from left and right sub-expr added together plus 1.</p>
<pre><code class="language-scl">rel weight(e, 1) = case e is Var(_) or case e is Const(_)
rel weight(e, l + r + 1) = case e is Add(a, b) and weight(a, l) and weight(b, r)
</code></pre>
<p>Lastly, we use the aggregation to find the equivalent programs with the minimum weight, which is our definition of the &quot;simplest&quot; program.
Note that we have used an <code>argmax</code> aggregation denoted by <code>min[p]</code> here:</p>
<pre><code class="language-scl">rel best_program(p) = p := argmin[p](w: input_expr(e) and equivalent(e, p) and weight(p, w))
</code></pre>
<p>If we query for the best program and turn it into string, we will get our expected output, a single variable <code>&quot;a&quot;</code>!</p>
<pre><code class="language-scl">rel best_program_str(s) = best_program(p) and to_string(p, s)
query best_program_str // {(&quot;a&quot;)}
</code></pre>
<h2 id="parsing-entities-from-string"><a class="header" href="#parsing-entities-from-string">Parsing Entities from String</a></h2>
<p>Scallop provides foreign functions and predicates for dynamically parsing entities from string input.
Consider the following example:</p>
<pre><code class="language-scl">type Expr = Const(f32) | Add(Expr, Expr)

rel expr_str = {&quot;Add(Const(1), Const(2.5))&quot;}
</code></pre>
<p>Let us say that we want to parse an expression from the <code>expr_str</code>, we can do the following:</p>
<pre><code class="language-scl">rel expr($parse_entity(s)) = expr_str(s)
</code></pre>
<p>Here, we are using the foreign function of <code>$parse_entity</code>.
We would get the following result:</p>
<pre><code class="language-scl">query expr
// expr: {(entity(0xadea13a2621dd155))}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on-demand-relations"><a class="header" href="#on-demand-relations">On-Demand Relations</a></h1>
<p>There are often times relations/predicates where you know that would not need to be fully computed.
This would include the infinite relations.
This means that, we want to define such relations without worrying about its infinite-ness while also being able to supply it with information needed for the computation.
Such relations are called <strong>On-Demand Relations</strong>.</p>
<p>We show here one on-demand relation which is the <code>fibonacci</code> number relation:</p>
<pre><code class="language-scl">type fib(bound x: i32, y: i32)
rel fib = {(0, 1), (1, 1)}
rel fib(x, y1 + y2) = fib(x - 1, y1) and fib(x - 2, y2) and x &gt; 1
query fib(10, y)
</code></pre>
<p>Normally, if we define the fibonacci relation, it would only contain the second and the third line, which respectively defines the base cases and the recursive cases.
However, as we all know, there are infinitely many fibonacci numbers and it would not be wise to compute the relation fully.
Usually, we want to infer some fact inside of the infinite relation, based on some inputs.
In this case, as noted on the last line, we want to know the 10th fibonacci number.</p>
<p>It is hinted that when we want to compute a fibonacci number, we usually supply the <code>x</code> value, in this case, 10, in order to get the value <code>y</code>.
This is exactly what we tell the compiler in the first line.
Inside of the type declaration, we provide an additional <strong>adornment</strong> to each of the variables.</p>
<ul>
<li><code>x</code> is adorned by <code>bound</code>, denoting that it is treated as an <strong>input</strong> (or <strong>bounded</strong>) variable to the relation</li>
<li><code>y</code> is not adorned by anything, suggesting that it is a <strong>free</strong> variable which will be computed by the rules of the relation</li>
</ul>
<blockquote>
<p>Getting <code>x</code> based on <code>y</code> is out-of-scope in this tutorial.</p>
</blockquote>
<p>By providing the adornments (with at least one <code>bound</code>), we are telling Scallop that the relation should be computed <em>on-demand</em>.
From there, Scallop will search for every place where the relation is <strong>demanded</strong>, and restrict the computation of the relation only on the demand.</p>
<p>In our case, there is just one single place where the <code>fib</code> relation is demanded (where <code>x</code> is <code>10</code>).
Therefore, Scallop will compute only the necessary facts in order to derive the final solution.</p>
<h2 id="adornments"><a class="header" href="#adornments">Adornments</a></h2>
<p>There are only two kinds of adornments:</p>
<ul>
<li><code>bound</code></li>
<li><code>free</code></li>
</ul>
<p>Annotating whether the variable is treated as <em>bounded</em> variable or <em>free</em> variable.</p>
<p>If an adornment is not provided on a variable, then it is by default a <code>free</code> variable.
In this sense, all normal relations without any adornment would be treated as <strong>non</strong>-on-demand relations.</p>
<p>When at least one <code>bound</code> adornment is annotated on a relation type declaration, we know that the relation needs to be computed <em>on-demand</em>.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h2>
<h3 id="on-demand-path"><a class="header" href="#on-demand-path">On-Demand Path</a></h3>
<p>Let's go back to our example of edge-and-path.
Consider that there is a huge graph, but we only want to know a path ending at a specific node:</p>
<pre><code class="language-scl">rel path(a, b) = edge(a, b) or (edge(a, c) and path(c, b))
query path(a, 1024)
</code></pre>
<p>In this case, enumerating all paths would be strictly more expensive than just exploring from the end point.
Therefore, we add an adornment to the <code>path</code> relation like the following:</p>
<pre><code class="language-scl">type path(free i32, bound i32)
</code></pre>
<p>We say the second argument is <code>bound</code> and the first argument is <code>free</code>, matching what we expect from the query.</p>
<h3 id="on-demand-to-string"><a class="header" href="#on-demand-to-string">On-Demand To-String</a></h3>
<p>Let's consider an simple arithmetic expression language and a <code>to_string</code> predicate for the language:</p>
<pre><code class="language-scl">type Expr = Const(i32) | Var(String) | Add(Expr, Expr) | Sub(Expr, Expr)

rel to_string(e, $format(&quot;{}&quot;, i))             = case e is Const(i)
rel to_string(e, $format(&quot;{}&quot;, v))             = case e is Var(e)
rel to_string(e, $format(&quot;({} + {})&quot;, s1, s2)) = case e is Add(e1, e2) and to_string(e1, s1) and to_string(e2, s2)
rel to_string(e, $format(&quot;({} - {})&quot;, s1, s2)) = case e is Sub(e1, e2) and to_string(e1, s1) and to_string(e2, s2)
</code></pre>
<p>Now that let's say there are many expressions declared as constants:</p>
<pre><code class="language-scl">const EXPR_1 = Add(Const(1), Add(Const(5), Const(3)))
const EXPR_2 = Add(Const(1), Var(&quot;x&quot;))
const EXPR_3 = Const(13)
</code></pre>
<p>Scallop would have automatically generated string for all of the expressions.</p>
<p>However, let's say we are only interested in one of the expressions:</p>
<pre><code class="language-scl">query to_string(EXPR_3, s)
</code></pre>
<p>Then most of the computations for <code>to_string</code> would be redundant.</p>
<p>In this case, we would also declare <code>to_string</code> as an on-demand predicate, like this:</p>
<pre><code class="language-scl">type to_string(bound Expr, String)
</code></pre>
<p>Then only the queried expression will be <code>to_string</code>-ed.</p>
<h2 id="internals"><a class="header" href="#internals">Internals</a></h2>
<p>Internally, when there are relations being annotated with adornments, the whole Scallop program is undergone a program transformation.
This transformation is traditionally called <strong>Magic-Set Transformation</strong> or <strong>Demand Transformation</strong>.
There are multiple papers on the topic, which we reference below:</p>
<ul>
<li><a href="https://arxiv.org/pdf/1909.08246.pdf">Extended Magic for Negation (Tuncay Tekle et. al. 2019)</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/1836089.1836094">Precise complexity analysis for efficient datalog queries (Tuncay Tekle et. al. 2010)</a></li>
<li><a href="https://www.sciencedirect.com/science/article/pii/074310669190030S">Efficient bottom-up computation of queries on stratified databases (Balbin et. al. 1991)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-from-csv"><a class="header" href="#loading-from-csv">Loading from CSV</a></h1>
<p>Scallop can be used along with existing datasets loaded from CSVs.
This is usually achieved with annotating on specific relations.
For example, assuming we have a file <code>edge.csv</code>,</p>
<pre><code class="language-csv">0,1
1,2
</code></pre>
<p>we can load the content of it into a relation <code>edge</code> in Scallop using the following syntax</p>
<pre><code class="language-scl">@file(&quot;edge.csv&quot;)
type edge(from: usize, to: usize)

rel path(a, c) = edge(a, c) or path(a, b) and edge(b, c)

query path
</code></pre>
<p>In particular, we annotate the <code>@file(...)</code> attribute onto the relation type declaration <code>type edge(...)</code>.
The file name is written inside the <code>@file</code> attribute.
We require the relation to be declared with types in order for it to be loaded with CSV file content.
Depending on the type declaration, the file content will be parsed into values of certain types.</p>
<p>From here, the <code>edge</code> relation will be loaded with the content <code>(0, 1)</code> and <code>(1, 2)</code>.
After executing the Scallop program above, we would obtain the result <code>path</code> being <code>(0, 1)</code>, <code>(0, 2)</code>, and <code>(1, 2)</code>.</p>
<p>Certainly, there are many ways to load CSV.
In this section, we introduce the various ways to configure the CSV loading.</p>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<p>There are CSV files with headers.
Suppose we have the following CSV file</p>
<pre><code class="language-csv">from,to
0,1
1,2
</code></pre>
<p>To load this file, we would need to add an additional argument <code>header=true</code> to the <code>@file</code> attribute:</p>
<pre><code class="language-scl">@file(&quot;edge.csv&quot;, header=true)
type edge(from: usize, to: usize)
</code></pre>
<p>Note that by default we assume that CSV files don't have headers.</p>
<h2 id="deliminators"><a class="header" href="#deliminators">Deliminators</a></h2>
<p>By default, we assume the values inside of the CSV file are deliminated by commas <code>','</code>.
In case where CSV files have values deliminated by other characters, such as tabs <code>'\t'</code>, we would need to specify that in the <code>@file</code> attribute:</p>
<pre><code class="language-scl">@file(&quot;edge.csv&quot;, deliminator=&quot;\t&quot;)
type edge(from: usize, to: usize)
</code></pre>
<p>Note that deliminators cannot be of multiple characters.</p>
<h2 id="parsing-field-value-pairs"><a class="header" href="#parsing-field-value-pairs">Parsing Field-Value Pairs</a></h2>
<p>There are many CSV tables which have a lot of columns.
One way is to specify all the fields and their types, like the following.</p>
<pre><code class="language-scl">type table(field1: type1, field2: type2, ..., fieldn: typen)
</code></pre>
<p>However, this might be very hard to encode.
Therefore, we provide another way of parsing CSV files into relations, by using primary keys and field-value pairs.
Let's assume we have the following CSV file:</p>
<pre><code class="language-csv">student_id,name,year,gender
0001,alice,2020,female
0002,bob,2021,male
</code></pre>
<p>We see that <code>student_id</code> can serve as the primary key of this table.
With this, it can be loaded into the following relation</p>
<pre><code class="language-scl">@file(&quot;student.csv&quot;, keys=&quot;student_id&quot;)
type table(student_id: usize, field: String, value: String)
</code></pre>
<p>By specifying <code>keys=&quot;student&quot;</code>, we tell Scallop that <code>student_id</code> should be viewed as unique primary keys.
The rest of the two elements are <code>field</code> and <code>value</code>, both need to be typed <code>String</code>s.
As a result, it produces the following 6 facts in the <code>table</code> relation:</p>
<pre><code>(1, &quot;name&quot;, &quot;alice&quot;), (1, &quot;year&quot;, &quot;2020&quot;), (1, &quot;gender&quot;, &quot;female&quot;),
(2, &quot;name&quot;, &quot;bob&quot;),   (2, &quot;year&quot;, &quot;2021&quot;), (2, &quot;gender&quot;, &quot;male&quot;)
</code></pre>
<p>Note that there could be more than one keys.
Consider the following table</p>
<pre><code>student_id,course_id,enroll_time,grade
0001,cse100,fa2020,a
0001,cse101,sp2021,a
0002,cse120,sp2021,b
</code></pre>
<p>We see that the combination of <code>student_id</code> and <code>course_id</code> form the unique primary keys.
In this case, they can be loaded using the following syntax:</p>
<pre><code class="language-scl">@file(&quot;enrollment.csv&quot;, keys=[&quot;student_id&quot;, &quot;course_id&quot;])
type enrollment(student_id: usize, course_id: String, field: String, value: String)
</code></pre>
<p>By setting <code>keys</code> to be a list <code>[&quot;student_id&quot;, &quot;course_id&quot;]</code>, the <code>student_id</code> field is the first primary key and <code>course_id</code> is the second.
There are still two additional arguments for the <code>enrollment</code> relation.
In general, the arity of the relation will be the number of primary keys plus 2.</p>
<h2 id="specifying-fields-to-load"><a class="header" href="#specifying-fields-to-load">Specifying Fields to Load</a></h2>
<p>In case not all fields are desired when loading, one can use the <code>fields</code> argument to specify what to load.
Consider the same enrollment table encoded in CSV:</p>
<pre><code class="language-csv">student_id,course_id,enroll_time,grade
0001,cse100,fa2020,a
0001,cse101,sp2021,a
0002,cse120,sp2021,b
</code></pre>
<p>If we only want to get everything but omit the <code>enroll_time</code> column, we can do</p>
<pre><code class="language-scl">@file(&quot;enrollment.csv&quot;, fields=[&quot;student_id&quot;, &quot;course_id&quot;, &quot;grade&quot;])
type enrollment(student_id: usize, course_id: String, grade: String)
</code></pre>
<p>This can also work in conjunction with the <code>keys</code> argument.
In this case, we do not need to specify the primary keys.</p>
<pre><code class="language-scl">@file(&quot;enrollment.csv&quot;, keys=[&quot;student_id&quot;, &quot;course_id&quot;], fields=[&quot;grade&quot;])
type enrollment(student_id: usize, course_id: String, field: String, value: String)
// The following facts will be obtained
//   enrollment(1, &quot;cse100&quot;, &quot;grade&quot;, &quot;a&quot;)
//   enrollment(1, &quot;cse101&quot;, &quot;grade&quot;, &quot;a&quot;)
//   enrollment(2, &quot;cse120&quot;, &quot;grade&quot;, &quot;b&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-functions"><a class="header" href="#foreign-functions">Foreign Functions</a></h1>
<p>Foreign functions allows for complex value manipulation in Scallop.
Conceptually, they are pure and partial functions that operate on value(s) and return one single value only.
Functions with states, such as <code>random</code>, are not allowed as foreign functions.</p>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>In Scallop, foreign functions are generically typed with optional and variable arguments.
All the functions have a dollar sign (<code>$</code>) associated with the function name.
We use the following syntax to denote a function signature</p>
<pre><code>$FUNC_NAME&lt;ARG(: FAMILY)?, ...&gt;(
  POS_ARG: POS_ARG_TYPE, ...,
  OPT_ARG: OPT_ARG_TYPE?, ...,
  VAR_ARG_TYPE...
) -&gt; RETURN_TYPE
</code></pre>
<p>The generic arguments are specified in the <code>&lt;...&gt;</code> after the function name, and can be annotated by optional type family.
For the arguments of the function, optional arguments have to appear after all positional arguments, and the variable arg type must appear after all positional and optional arguments.
Functions must have a return type.</p>
<p>For example, the function <code>$string_char_at(s: String, i: usize) -&gt; char</code> takes in a string <code>s</code> and an index <code>i</code>, and returns the character at that location.
The two arguments <code>s</code> and <code>i</code> are both positional arguments.</p>
<p>In the function <code>$substring(s: String, b: usize, e: usize?)</code>, we have 2 positional arguments (<code>s</code> and <code>b</code>) and 1 optional argument (<code>e</code>).
This means that this substring function can be invoked with 2 or 3 arguments.
Invoking <code>$substring(&quot;hello&quot;, 3)</code> would give us <code>&quot;lo&quot;</code>, and invoking <code>$substring(&quot;hello&quot;, 1, 3)</code> would give us <code>&quot;el&quot;</code>.</p>
<p>For functions like <code>$abs&lt;T: Number&gt;(T) -&gt; T</code>, we have absolute value function taking in value of any type that is a number (including integers and floating points).
The function also returns a type the same as the input.</p>
<p>For a function like <code>$format(f: String, Any...)</code>, it looks at the format string and fill all the <code>{}</code> symbol in the string with the latter arguments.
Notice how there can be arbitrary number of arguments (variable arg) of <code>Any</code> type.
For example, we can have <code>$format(&quot;{} + {}&quot;, 3, &quot;a&quot;) ==&gt; &quot;3 + a&quot;</code> and <code>$format(&quot;{}&quot;, true) ==&gt; &quot;true&quot;</code>.</p>
<h2 id="function-failures"><a class="header" href="#function-failures">Function Failures</a></h2>
<p>Foreign functions may fail with errors such as divide-by-zero, index-out-of-bounds.
When error happens, values will not be propagated along the computation, and will be dropped silently.</p>
<p>For example, the following program makes use of the foreign function <code>$string_char_at</code>.
It walks through the indices 1, 3, and 5, and get the character on those indices of the string <code>&quot;hello&quot;</code>.</p>
<pre><code class="language-scl">rel indices = {1, 3, 5}
rel output(i, $string_char_at(&quot;hello&quot;, i)) = indices(i)
</code></pre>
<p>However, there are only 5 characters in the string, meaning that getting the <code>5</code>-th character would result in an index-out-of-bounds error.
Scallop will drop this invokation silently, resulting in only two facts being derived:</p>
<pre><code>output: {(1, 'e'), (3, 'l')}
</code></pre>
<p>Similar things happen when <code>nan</code> is derived from floating point operations, or that the foreign function fails.</p>
<h2 id="library-of-foreign-functions"><a class="header" href="#library-of-foreign-functions">Library of Foreign Functions</a></h2>
<p>We hereby list all the available foreign functions, their signatures, descriptions, and an example of how to invoke them.
The functions here are ordered alphabetically.
For some of the functions that are slightly more complicated (e.g. <code>$format</code>), please refer to the section below for more information.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Function</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>$abs&lt;T: Number&gt;(x: T) -&gt; T</code></td><td>Absolute value function \(\lvert x \rvert\)</td><td><code>$abs(-1)</code> =&gt; <code>1</code></td></tr>
<tr><td style="text-align: left"><code>$acos&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Arc cosine function \(\text{acos}(x)\)</td><td><code>$acos(0.0)</code> =&gt; <code>1.5708</code></td></tr>
<tr><td style="text-align: left"><code>$atan&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Arc tangent function \(\text{atan}(x)\)</td><td><code>$atan(0.0)</code> =&gt; <code>0.0</code></td></tr>
<tr><td style="text-align: left"><code>$atan2&lt;T: Float&gt;(y: T, x: T) -&gt; T</code></td><td>2-argument arc tangent function \( \text{atan}(y, x) \)</td><td><code>$atan2(0.0, 1.0)</code> =&gt; <code>0.0</code></td></tr>
<tr><td style="text-align: left"><code>$ceil&lt;T: Number&gt;(x: T) -&gt; T</code></td><td>Round <em>up</em> to closest integer \( \lceil x \rceil \)</td><td><code>$ceil(0.5)</code> =&gt; <code>1.0</code></td></tr>
<tr><td style="text-align: left"><code>$cos&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Cosine function \(\text{cos}(x)\)</td><td><code>$cos(0.0)</code> =&gt; <code>1.0</code></td></tr>
<tr><td style="text-align: left"><code>$datetime_day(d: DateTime) -&gt; u32</code></td><td>Get the day component of a <code>DateTime</code>, starting from 1</td><td><code>$datetime_day(t&quot;2023-01-01&quot;)</code> =&gt; <code>1</code></td></tr>
<tr><td style="text-align: left"><code>$datetime_month(d: DateTime) -&gt; u32</code></td><td>Get the month component of a <code>DateTime</code>, starting from 1</td><td><code>$datetime_month(t&quot;2023-01-01&quot;)</code> =&gt; <code>1</code></td></tr>
<tr><td style="text-align: left"><code>$datetime_month0(d: DateTime) -&gt; u32</code></td><td>Get the month component of a <code>DateTime</code>, starting from 0</td><td><code>$datetime_month0(t&quot;2023-01-01&quot;)</code> =&gt; <code>0</code></td></tr>
<tr><td style="text-align: left"><code>$datetime_year(d: DateTime) -&gt; i32</code></td><td>Get the year component of a <code>DateTime</code></td><td><code>$datetime_month0(t&quot;2023-01-01&quot;)</code> =&gt; <code>2023</code></td></tr>
<tr><td style="text-align: left"><code>$dot(a: Tensor, b: Tensor) -&gt; Tensor</code></td><td>Dot product of two tensors \(a \cdot b\); only available when compiled with <code>torch-tensor</code></td><td></td></tr>
<tr><td style="text-align: left"><code>$exp&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Exponential function \(e^x\)</td><td><code>$exp(0.0)</code> =&gt; <code>1.0</code></td></tr>
<tr><td style="text-align: left"><code>$exp2&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Exponential function \(2^x\) (base 2)</td><td><code>$exp2(2.0)</code> =&gt; <code>4.0</code></td></tr>
<tr><td style="text-align: left"><code>$floor&lt;T: Number&gt;(x: T) -&gt; T</code></td><td>Round <em>down</em> to closest integer \(\lfloor x \rfloor\)</td><td><code>$exp2(2)</code> =&gt; <code>4</code></td></tr>
<tr><td style="text-align: left"><code>$format(String, Any...) -&gt; String</code></td><td>Formatting string</td><td><code>$format(&quot;{} + {}&quot;, 3, &quot;a&quot;)</code> =&gt; <code>&quot;3 + a&quot;</code></td></tr>
<tr><td style="text-align: left"><code>$hash(Any...) -&gt; u64</code></td><td>Hash the given values</td><td><code>$hash(&quot;a&quot;, 3, 5.5)</code> =&gt; <code>5862532063111067262</code></td></tr>
<tr><td style="text-align: left"><code>$log&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Natural logarithm function \(\text{log}_e(x)\)</td><td><code>$log(1.0)</code> =&gt; <code>0.0</code></td></tr>
<tr><td style="text-align: left"><code>$log2&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Logarithm function \(\text{log}_2(x)\) (base 2)</td><td><code>$log2(4.0)</code> =&gt; <code>2.0</code></td></tr>
<tr><td style="text-align: left"><code>$max&lt;T: Number&gt;(T...) -&gt; T</code></td><td>Maximum \(\text{max}(x_1, x_2, \dots)\)</td><td><code>$max(4.0, 1.0, 9.5)</code> =&gt; <code>9.5</code></td></tr>
<tr><td style="text-align: left"><code>$min&lt;T: Number&gt;(T...) -&gt; T</code></td><td>Minimum \(\text{min}(x_1, x_2, \dots)\)</td><td><code>$max(4.0, 1.0, 9.5)</code> =&gt; <code>1.0</code></td></tr>
<tr><td style="text-align: left"><code>$pow&lt;T: Integer&gt;(x: T, y: u32) -&gt; T</code></td><td>Integer power function \(x^y\)</td><td><code>$pow(2.2, 2)</code> =&gt; <code>4.84</code></td></tr>
<tr><td style="text-align: left"><code>$powf&lt;T: Float&gt;(x: T, y: T) -&gt; T</code></td><td>Float power function \(x^y\)</td><td><code>$powf(4.0, 0.5)</code> =&gt; <code>2.0</code></td></tr>
<tr><td style="text-align: left"><code>$sign&lt;T: Number&gt;(x: T) -&gt; T</code></td><td>Sign function that returns \({-1, 0, 1}\) in respective types</td><td><code>$sign(-3.0)</code> =&gt; <code>-1.0</code></td></tr>
<tr><td style="text-align: left"><code>$sin&lt;T: Float&gt;(x: T) -&gt; T</code></td><td>Sine function \(\text{sin}(x)\)</td><td><code>$sin(0.0)</code> =&gt; <code>0.0</code></td></tr>
<tr><td style="text-align: left"><code>$string_char_at(s: String, i: usize) -&gt; char</code></td><td>Get the <code>i</code>-th character of string <code>s</code></td><td><code>$string_char_at(&quot;hello&quot;, 2)</code> =&gt; <code>'l'</code></td></tr>
<tr><td style="text-align: left"><code>$string_concat(String...) -&gt; String</code></td><td>Concatenate multiple strings</td><td><code>$string_concat(&quot;hello&quot;, &quot; &quot;, &quot;world&quot;)</code> =&gt; <code>&quot;hello world&quot;</code></td></tr>
<tr><td style="text-align: left"><code>$string_index_of(s: String, pat: String) -&gt; usize</code></td><td>Find the index of the first occurrence of the pattern <code>pat</code> in string <code>s</code></td><td><code>$string_index_of(&quot;hello world&quot;, &quot;world&quot;)</code> =&gt; <code>6</code></td></tr>
<tr><td style="text-align: left"><code>$string_length(s: String) -&gt; usize</code></td><td>Get the length of the string</td><td><code>$string_length(&quot;hello&quot;)</code> =&gt; <code>5</code></td></tr>
<tr><td style="text-align: left"><code>$string_lower(s: String) -&gt; String</code></td><td>To lower-case</td><td><code>$string_lower(&quot;LisA&quot;)</code> =&gt; <code>&quot;lisa&quot;</code></td></tr>
<tr><td style="text-align: left"><code>$string_trim(s: String) -&gt; String</code></td><td>Trim a string</td><td><code>$string_trim(&quot;  hello &quot;)</code> =&gt; <code>&quot;hello&quot;</code></td></tr>
<tr><td style="text-align: left"><code>$string_upper(s: String) -&gt; String</code></td><td>To upper-case</td><td><code>$string_upper(&quot;LisA&quot;)</code> =&gt; <code>&quot;LISA&quot;</code></td></tr>
<tr><td style="text-align: left"><code>$substring(s: String, b: usize, e: usize?) -&gt; String</code></td><td>Find the substring given begin index and optional the end index</td><td><code>$substring(&quot;hello world&quot;, 6)</code> =&gt; <code>&quot;world&quot;</code></td></tr>
<tr><td style="text-align: left"><code>$tan&lt;T: Number&gt;(x: T) -&gt; T</code></td><td>Tangent function \(\text{tan}(x)\)</td><td><code>$tan(0.0)</code> =&gt; <code>0.0</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-predicates"><a class="header" href="#foreign-predicates">Foreign Predicates</a></h1>
<p>Foreign predicates aim to provide programmers with extra capabilities with relational predicates.
Traditional Datalog program defines relational predicate using only horn-rules.
Given the assumption that the input database is finite, these derived relational predicates will also be finite.
However, there are many relational predicates that are infinite and could not be easily expressed by horn-rules.
One such example is the <code>range</code> relation.
Suppose it is defined as <code>range(begin, end, i)</code> where <code>i</code> could be between <code>begin</code> (inclusive) and <code>end</code> (exclusive).
There could be infinitely many triplets, and we cannot simply enumerate all of them.
But if the first two arguments <code>begin</code> and <code>end</code> are given, we can reasonably enumerate the <code>i</code>.</p>
<p>In Scallop, <code>range</code> is available to be used as a <strong>foreign predicate</strong>.
Notice that <code>range</code> can be applied on any integer data, making it a generic predicate.
For example, to use <code>range</code> on <code>i32</code> data, we will need to invoke <code>range&lt;i32&gt;</code>:</p>
<pre><code class="language-scl">rel result(x) = range&lt;i32&gt;(0, 5, x)
</code></pre>
<p>Here we enumerate the value of <code>x</code> from 0 (inclusive) to 5 (exclusive), meaning that we will obtain that <code>result = {0, 1, 2, 3, 4}</code>.
For the rest of this section, we describe in detail how foreign predicates are constructed in Scallop and why are they useful.</p>
<h2 id="foreign-predicate-types"><a class="header" href="#foreign-predicate-types">Foreign Predicate Types</a></h2>
<p>Foreign predicates can be generic and are statically typed.
In addition to just providing the argument types, we also need to provide a boundness pattern.</p>
<p>A boundness pattern is a string of length equal to the relation arity and consisting of <code>b</code> and <code>f</code>.
The character <code>b</code> means <em>bounded</em>, reflecting the variable on that position is taken as input to the predicate.
The character <code>f</code> means <em>free</em>, suggesting that the variable on that position will be generated as output by the predicate.</p>
<p>For example, the full definition of <code>range</code> is</p>
<pre><code>range&lt;T: Integer&gt;(begin: T, end: T, i: T)[bbf]
</code></pre>
<p>Notice that at the end of the definition we have <code>[bbf]</code>.
Here, <code>bbf</code> is a boundness pattern for range, suggesting that <code>begin</code> and <code>end</code> will be provided as input, and <code>i</code> will be generated as output.</p>
<blockquote>
<p>In the future, we plan to allow the definition of multiple boundness patterns</p>
</blockquote>
<h2 id="standard-library-of-foreign-predicates-part-a"><a class="header" href="#standard-library-of-foreign-predicates-part-a">Standard Library of Foreign Predicates (Part A)</a></h2>
<p>In this part, we give an overview to the foreign predicates that are discrete only.</p>
<div class="table-wrapper"><table><thead><tr><th>Foreign Predicate</th><th>Description</th></tr></thead><tbody>
<tr><td><code>datetime_ymd(d: DateTime, y: i32, m: u32, d: u32)[bfff]</code></td><td>Get the <code>y</code>ear, <code>m</code>onth, and <code>day</code> from a <code>DateTime</code> value</td></tr>
<tr><td><code>range&lt;T: Integer&gt;(begin: T, end: T, i: T)[bbf]</code></td><td>Generate all the integers <code>i</code> starting from <code>begin</code> and end with <code>end - 1</code></td></tr>
<tr><td><code>string_chars(s: String, i: usize, c: char)[bff]</code></td><td>Generate all the index-character tuples inside of string <code>s</code></td></tr>
<tr><td><code>string_find(s: String, pat: String, begin: usize, end: usize)[bbff]</code></td><td>Generate all the begin-end ranges of the pattern <code>pat</code>'s occurrence in the string <code>s</code></td></tr>
<tr><td><code>string_split(s: String, pat: String, out: String)[bbf]</code></td><td>Split the string <code>s</code> using the pattern <code>pat</code> and generate the <code>out</code> strings</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="reference-guide"><a class="header" href="#reference-guide">Reference Guide</a></h1>
<p>We list all the language features supported by Scallop.</p>
<h2 id="import-files"><a class="header" href="#import-files">Import Files</a></h2>
<pre><code class="language-scl">import &quot;path/to/other/file.scl&quot;
</code></pre>
<h2 id="type-definition"><a class="header" href="#type-definition">Type Definition</a></h2>
<h3 id="type-alias-definition"><a class="header" href="#type-alias-definition">Type Alias Definition</a></h3>
<pre><code class="language-scl">type ObjectId = usize
</code></pre>
<h3 id="sub-type-definition"><a class="header" href="#sub-type-definition">Sub-Type Definition</a></h3>
<pre><code class="language-scl">type Name &lt;: String
</code></pre>
<h3 id="enum-type-definition"><a class="header" href="#enum-type-definition">Enum Type Definition</a></h3>
<pre><code class="language-scl">type Action = LEFT | RIGHT | UP | DOWN
</code></pre>
<h3 id="algebraic-data-type-definition"><a class="header" href="#algebraic-data-type-definition">Algebraic Data Type Definition</a></h3>
<pre><code class="language-scl">type Expr = Const(i32) | Add(Expr, Expr) | Sub(Expr, Expr)
</code></pre>
<h3 id="relation-type-definition"><a class="header" href="#relation-type-definition">Relation Type Definition</a></h3>
<pre><code class="language-scl">type edge(x: i32, y: i32)
</code></pre>
<h2 id="constant-definition"><a class="header" href="#constant-definition">Constant Definition</a></h2>
<pre><code class="language-scl">const PI: f32 = 3.1415
</code></pre>
<h2 id="relation-definition"><a class="header" href="#relation-definition">Relation Definition</a></h2>
<h3 id="fact-definition"><a class="header" href="#fact-definition">Fact Definition</a></h3>
<pre><code class="language-scl">rel edge(1, 2)
</code></pre>
<h3 id="set-of-tuples-definition"><a class="header" href="#set-of-tuples-definition">Set-of-Tuples Definition</a></h3>
<pre><code class="language-scl">rel edge = {(1, 2), (2, 3), (3, 4)}
</code></pre>
<h3 id="rule-definition"><a class="header" href="#rule-definition">Rule Definition</a></h3>
<pre><code class="language-scl">rel path(a, b) = edge(a, b) or path(a, c) and edge(c, b)
</code></pre>
<h4 id="disjunctive-head"><a class="header" href="#disjunctive-head">Disjunctive Head</a></h4>
<pre><code class="language-scl">rel { assign(v, false); assign(v, true) } = variable(v)
</code></pre>
<h4 id="atom-1"><a class="header" href="#atom-1">Atom</a></h4>
<pre><code class="language-scl">fib(x - 1, y)
</code></pre>
<h4 id="negation"><a class="header" href="#negation">Negation</a></h4>
<pre><code class="language-scl">rel has_no_child(p) = person(p) and not father(p, _) and not mother(p, _)
</code></pre>
<h4 id="constraint"><a class="header" href="#constraint">Constraint</a></h4>
<pre><code class="language-scl">rel number(0)
rel number(i + 1) = number(i) and i &lt; 10
</code></pre>
<h4 id="aggregation"><a class="header" href="#aggregation">Aggregation</a></h4>
<pre><code class="language-scl">rel person = {&quot;alice&quot;, &quot;bob&quot;, &quot;christine&quot;}
rel num_people(n) = n := count(p: person(p))
</code></pre>
<h4 id="foreign-predicate"><a class="header" href="#foreign-predicate">Foreign Predicate</a></h4>
<pre><code class="language-scl">rel grid(x, y) = range&lt;i32&gt;(0, 5, x) and range&lt;i32&gt;(0, 5, y)
</code></pre>
<h2 id="query-definition"><a class="header" href="#query-definition">Query Definition</a></h2>
<pre><code class="language-scl">query path
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-and-probabilistic-programming-1"><a class="header" href="#scallop-and-probabilistic-programming-1">Scallop and Probabilistic Programming</a></h1>
<p>One fundamental concept in machine learning is <em>probability</em>.
Scallop, being a neurosymbolic programming language, supports probability and probabilistic programming natively.
For example, one can write the following program:</p>
<pre><code class="language-scl">type Action = UP | DOWN | LEFT | RIGHT
rel predicted_action = {0.05::UP, 0.09::DOWN, 0.82::LEFT, 0.04::RIGHT}
</code></pre>
<p>where the <code>predicted_action</code> relation encodes a distribution of actions and their probabilities.
In particular, the <code>UP</code> action is predicted to have a \(0.05\) probability.
Here, the <code>::</code> symbol is used to suggest that probabilities (such as 0.05) are used to <em>tag</em> the facts (such as <code>UP</code>).</p>
<p>Since we can define probability on user declared facts, the derivation of new facts will be associated with probabilities too.
This means that Scallop is doing <em>probabilistic reasoning</em>.
The whole probabilistic reasoning semantics of Scallop is defined with the theory of <em>provenance semiring</em>.
In this chapter, we give detailed explanation to the probabilities appeared in Scallop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tags-and-provenance"><a class="header" href="#tags-and-provenance">Tags and Provenance</a></h1>
<p>Scallop's probabilistic semantics is realized by the <em>Provenance Semiring</em> framework.
Inside of this framework, each fact can be <em>tagged</em> by an extra piece of information, which we call <em>tag</em>.
Such information is propagated throughout the execution of Scallop program according to the <em>provenance</em>, which is the mathematical object defining how tags propagate.</p>
<h2 id="motivating-probabilistic-example"><a class="header" href="#motivating-probabilistic-example">Motivating Probabilistic Example</a></h2>
<p>The following example shows a fact <code>earthquake()</code> being tagged by a probability <code>0.03</code> (earthquake could happen with a 0.03 probability):</p>
<pre><code class="language-scl">rel 0.03::earthquake()
</code></pre>
<p>Concretely, we have an <em>(external) tag space</em> of \([0, 1]\), which contains real numbers between 0 and 1, which is the space of probabilities.
Similarly, we define another tagged fact <code>burglary()</code>:</p>
<pre><code class="language-scl">rel 0.20::burglary()
</code></pre>
<p>We can declare a rule saying that, &quot;when earthquake or burglary happens, an alarm will go off&quot;.</p>
<pre><code class="language-scl">rel alarm() = earthquake() or burglary()
query alarm
</code></pre>
<p>Remember that the facts <code>earthquake()</code> and <code>burglary()</code> are probabilistic.
Intuitively, the derived fact <code>alarm()</code> will also be associated with a derived probability.
Based on probability theory, we have</p>
<p>\[
\begin{align}
\Pr(\text{alarm})
&amp;= \Pr(\text{earthquake} \vee \text{burglary}) \\
&amp;= 1 - \Pr(\neg \text{earthquake} \wedge \neg \text{burglary}) \\
&amp;= 1 - \Pr(\neg \text{earthquake}) \cdot \Pr(\neg \text{burglary}) \\
&amp;= 1 - (1 - \Pr(\text{earthquake})) \cdot (1 - \Pr(\text{burglary})) \\
&amp;= 1 - (1 - 0.03) (1 - 0.20) \\
&amp;= 1 - 0.97 \times 0.8 \\
&amp;= 0.224
\end{align}
\]</p>
<p>This is indeed what we get if we use the <code>topkproofs</code> provenance (which we discuss later in the chapter) with the <code>scli</code> Scallop interpreter:</p>
<pre><code>&gt; scli alarm.scl
alarm: {0.224::()}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proofs-provenance"><a class="header" href="#proofs-provenance">Proofs Provenance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fact-with-probability"><a class="header" href="#fact-with-probability">Fact with Probability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logic-and-probability"><a class="header" href="#logic-and-probability">Logic and Probability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="aggregation-with-probability"><a class="header" href="#aggregation-with-probability">Aggregation with Probability</a></h1>
<p>With the introduction of probabilities, many existing aggregators are augmented with new semantics, which we typically call <em>multi-world semantics</em>.
What's more, there are new aggregators, such as <code>softmax</code>, <code>rank</code>, and <code>weighted_avg</code>, that make use of the probabilities.
We introduce these aggregators one-by-one in this section.</p>
<h2 id="multi-world-semantics-with-aggregators"><a class="header" href="#multi-world-semantics-with-aggregators">Multi-world Semantics with Aggregators</a></h2>
<p>Let us take the <code>count</code> aggregator as an example.
Consider we have 2 objects, each could be big or small with their respective probabilities:</p>
<pre><code class="language-scl">type OBJ = OBJ_A | OBJ_B
rel size = {0.8::(OBJ_A, &quot;big&quot;); 0.2::(OBJ_A, &quot;small&quot;)} // obj A is very likely big
rel size = {0.1::(OBJ_B, &quot;big&quot;); 0.9::(OBJ_B, &quot;small&quot;)} // obj B is very likely small
</code></pre>
<p>Now let's say we want to count how many big objects are there, by using the following</p>
<p>Note that even when using probabilites, one can opt to not use the multi-world semantics by adding <code>!</code> sign to the end of the aggregator.</p>
<h2 id="new-aggregators-using-probabilities"><a class="header" href="#new-aggregators-using-probabilities">New Aggregators using Probabilities</a></h2>
<h3 id="softmax-and-normalize"><a class="header" href="#softmax-and-normalize">Softmax and Normalize</a></h3>
<h3 id="rank"><a class="header" href="#rank">Rank</a></h3>
<h3 id="weighted-average-and-weighted-sum"><a class="header" href="#weighted-average-and-weighted-sum">Weighted Average and Weighted Sum</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sampling-with-probability"><a class="header" href="#sampling-with-probability">Sampling with Probability</a></h1>
<p>In Scallop, samplers share the same syntax as aggregators.
They usually work with probabilistic provenances, but can also work without them.
Here are some example samplers:</p>
<ul>
<li><code>top</code>: get the $k$ facts with top probabilities</li>
<li><code>categorical</code>: treat the relation as a categorical distribution and sample from it</li>
<li><code>uniform</code>: treat the relation as a uniform distribution and sample from it</li>
</ul>
<p>Let's take <code>top</code> as an example.
We can obtain the top ranked symbol by using the following rule:</p>
<pre><code class="language-scl">rel symbols = {0.9::&quot;+&quot;, 0.05::&quot;-&quot;, 0.02::&quot;3&quot;}
rel top_symbol(s) = s := top&lt;1&gt;(s: symbols(s)) // 0.9::top_symbol(&quot;+&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-proofs"><a class="header" href="#debugging-proofs">Debugging Proofs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-scallop-python-binding-scallopy"><a class="header" href="#the-scallop-python-binding-scallopy">The Scallop Python Binding <code>scallopy</code></a></h1>
<p><code>scallopy</code> is the Python binding for Scallop, offering an interface for computationg with Scallop in Python.
In addition, it can be integrated with <a href="https://pytorch.org">PyTorch</a>, allowing users to write Neuro-Symbolic applications that can be connected to PyTorch.
In this section, we elaborate on how to install, configure, and use the <code>scallopy</code> library.</p>
<p>For an example, please look at <a href="scallopy/getting_started.html">Getting Started</a>.
To start reading the documentation, proceed to <a href="scallopy/context.html">Scallopy Context</a></p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="todo-installation-with-venv"><a class="header" href="#todo-installation-with-venv">TODO: Installation with venv</a></h3>
<h3 id="todo-installation-with-conda"><a class="header" href="#todo-installation-with-conda">TODO: Installation with Conda</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-scallopy"><a class="header" href="#getting-started-with-scallopy">Getting Started with Scallopy</a></h1>
<h2 id="motivating-example"><a class="header" href="#motivating-example">Motivating Example</a></h2>
<p>Let's start with a very simple example illustrating the usage of <code>scallopy</code>.</p>
<pre><code class="language-python">import scallopy

ctx = scallopy.Context()

ctx.add_relation(&quot;edge&quot;, (int, int))
ctx.add_facts(&quot;edge&quot;, [(1, 2), (2, 3)])

ctx.add_rule(&quot;path(a, c) = edge(a, c) or path(a, b) and edge(b, c)&quot;)

ctx.run()

print(list(ctx.relation(&quot;path&quot;))) # [(1, 2), (1, 3), (2, 3)]
</code></pre>
<p>In this very simple edge-path example, we are interacting with Scallop through a Python class called <code>Context</code>.
Basically, a <code>Context</code> manages a Scallop program, along with the relations, facts, and execution results corresponding to that Scallop program.
We create a <code>Context</code> by <code>ctx = scallopy.Context</code>.
Relations, facts, and rules are added through the functions <code>add_relation(...)</code>, <code>add_facts(...)</code>, and <code>add_rule(...)</code>.
With everything set, we can execute the program inside the context by calling <code>run()</code>
Lastly, we pull the result from <code>ctx</code> by using <code>relation(...)</code>.
Please refer to a more detailed explanation of this example in <a href="scallopy/context.html">Scallop Context</a>.</p>
<h2 id="machine-learning-with-scallopy-and-pytorch"><a class="header" href="#machine-learning-with-scallopy-and-pytorch">Machine Learning with Scallopy and PyTorch</a></h2>
<p>When doing machine learning, we usually want to have batched inputs and outputs.
Instead of building the Scallop context incrementally and explicitly run the program, we can create a <code>Module</code> at once and be able to run the program for a batch of inputs.
This offers a few advantages, such as optimization during compilation, batched execution for integration with machine learning pipelines, simplified interaction between data structures, and so on.
For example, we can create a module and run it like the following:</p>
<pre><code class="language-python">import scallopy
import torch

# Creating a module for execution
my_sum2 = scallopy.Module(
  program=&quot;&quot;&quot;
    type digit_1(a: i32), digit_2(b: i32)
    rel sum_2(a + b) = digit_1(a) and digit_2(b)
  &quot;&quot;&quot;,
  input_mappings={&quot;digit_1&quot;: range(10), &quot;digit_2&quot;: range(10)},
  output_mappings={&quot;sum_2&quot;: range(19)},
  provenance=&quot;difftopkproofs&quot;)

# Invoking the module with torch tensors. `result` is a tensor of 16 x 19
result = my_sum2(
  digit_1=torch.softmax(torch.randn(16, 10), dim=0),
  digit_2=torch.softmax(torch.randn(16, 10), dim=0))
</code></pre>
<p>As can be seen in this example, we have defined a <code>Module</code> which can be treated also as a PyTorch module.
Similar to other PyTorch modules, it can take in torch tensors and return torch tensors.
The logical symbols (such as the <code>i32</code> numbers used in <code>digit_1</code> and <code>digit_2</code>) are configured in <code>input_mappings</code> and <code>output_mappings</code>, and can be automatically converted from tensors.
We also see that it is capable of handling a batch of inputs (here, the batch size is 16).
Internally, Scallop also knows to execute in parallel, making it performing much faster than normal.
Please refer to <a href="scallopy/module.html">Scallop Module</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-context"><a class="header" href="#scallop-context">Scallop Context</a></h1>
<p>The most fundamental point of interaction of <code>scallopy</code> is <code>ScallopContext</code>.
The following is a very simple example setting up a <code>ScallopContext</code> to compute the <code>edge-path</code> program:</p>
<pre><code class="language-py">import scallopy

# Creating a new context
ctx = scallopy.ScallopContext()

# Add relation of `edge`
ctx.add_relation(&quot;edge&quot;, (int, int))
ctx.add_facts(&quot;edge&quot;, [(0, 1), (1, 2)])

# Add rule of `path`
ctx.add_rule(&quot;path(a, c) = edge(a, c) or path(a, b) and edge(b, c)&quot;)

# Run!
ctx.run()

# Check the result!
print(list(ctx.relation(&quot;path&quot;))) # [(0, 1), (0, 2), (1, 2)]
</code></pre>
<p>Roughly, the program above can be divided into three phases:</p>
<ol>
<li>Setup the context: this involves defining relations, adding facts to relations, and adding rules that do the computation</li>
<li>Running the program inside of context</li>
<li>Fetch the results</li>
</ol>
<p>While the 2nd and 3rd steps are the place where the computation really happens, it's more important for the programmers to correctly setup the full context for computation.
We now elaborate on what are the high-level things to do when setting up the context</p>
<h2 id="configurations"><a class="header" href="#configurations">Configurations</a></h2>
<p>When creating a new <code>ScallopContext</code>, one should configure it with intended provenance.
If no argument is supplied, as shown in the above example, the context will be initialized with the default provenance, <code>unit</code>, which resembles untagged semantics (a.k.a. discrete Datalog).
To explicitly specify this, you can do</p>
<pre><code class="language-py">ctx = scallopy.ScallopContext(provenance=&quot;unit&quot;)
</code></pre>
<p>Of course, Scallop can be used to perform reasoning on probabilistic and differentiable inputs.
For instance, you can write the following</p>
<pre><code class="language-py">ctx = scallopy.ScallopContext(provenance=&quot;minmaxprob&quot;) # Probabilistic
# or
ctx = scallopy.ScallopContext(provenance=&quot;diffminmaxprob&quot;) # Differentiable
</code></pre>
<p>For more information on possible provenance information, please refer to the <a href="scallopy/scallopy/provenance.html">provenance</a> section.
It it worth noting that some provenance, such as <code>topkproofs</code>, accept additional parameters such as <code>k</code>.
In this case, you can supply this as additional arguments when creating the context:</p>
<pre><code class="language-py">ctx = scallopy.ScallopContext(provenance=&quot;topkproofs&quot;, k=5) # top-k-proofs provenance with k = 5
</code></pre>
<h2 id="adding-program"><a class="header" href="#adding-program">Adding Program</a></h2>
<p>Given that a context has been configured and initialized, we can set it up the quickest by loading a program into the context.
One can either load an external <code>.scl</code> file, or directly inserting a program written as Python string.
To directly add a full program string to the context, one can do</p>
<pre><code class="language-py">ctx.add_program(&quot;&quot;&quot;
  rel edge = {(0, 1), (1, 2)}
  rel path(a, c) = edge(a, c) or path(a, b) and edge(b, c)
&quot;&quot;&quot;)
</code></pre>
<p>On the other hand, assuming that there is a file <code>edge_path.scl</code> that contains the same content as the above string, one can do</p>
<pre><code class="language-py">ctx.import_file(&quot;edge_path.scl&quot;)
</code></pre>
<h2 id="adding-relations"><a class="header" href="#adding-relations">Adding Relations</a></h2>
<p>Instead of adding program as a whole, one can also add relations one-at-a-time.
When adding new relations, one would need to supply the name as well as the type of the relation.
For example, the <code>edge</code> relation can be defined as follows</p>
<pre><code class="language-py">ctx.add_relation(&quot;edge&quot;, (int, int))
</code></pre>
<p>Here, we are saying that <code>edge</code> is an arity-2 relation storing pairs of integers.
Note that we are specifying the type using Python's <code>int</code> type.
This is equivalent to the <code>i32</code> type inside Scallop.
Therefore, the above instruction tranlates to the following Scallop code:</p>
<pre><code class="language-scl">rel edge(i32, i32)
</code></pre>
<p>Many existing Python types can directly translate to Scallop type.
In particular, we have the mapping listed as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Python Type</th><th>Scallop Type</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>i32</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>float</code></td><td><code>f32</code></td></tr>
<tr><td><code>str</code></td><td><code>String</code></td></tr>
</tbody></table>
</div>
<p>In case one want to use types other than the listed ones (e.g., <code>usize</code>), they can be accessed directly using the string <code>&quot;usize&quot;</code>, or they can be accessed through predefined types such as <code>scallopy.usize</code>.
The example below defines a relation of type <code>(usize, f64, i32)</code>:</p>
<pre><code class="language-py">ctx.add_relation(&quot;my_relation&quot;, (scallopy.usize, &quot;f64&quot;, int))
</code></pre>
<p>Specifically for arity-1 relations, users don't need to use a tuple to specify the type.
For instance,</p>
<pre><code class="language-py">ctx.add_relation(&quot;digit&quot;, int)
</code></pre>
<h2 id="adding-facts"><a class="header" href="#adding-facts">Adding Facts</a></h2>
<p>The most basic version of adding facts into an existing relation inside of an existing context.
We are assuming that the context has a provenance of <code>&quot;unit&quot;</code>.</p>
<pre><code class="language-py">ctx.add_facts(&quot;edge&quot;, [(1, 2), (2, 3)])
</code></pre>
<p>If the relation is declared to be having arity-1 and that the type is a singleton type instead of a 1-tuple, then the facts inside of the list do not need to be a tuple.</p>
<pre><code class="language-py">ctx.add_relation(&quot;digit&quot;, int)
ctx.add_facts(&quot;digit&quot;, [1, 2, 3])
</code></pre>
<h3 id="probabilistic-facts-tagged-facts"><a class="header" href="#probabilistic-facts-tagged-facts">Probabilistic Facts (Tagged Facts)</a></h3>
<p>When the Scallop context is configured to use a provenance other than.
If one wants to add facts along with probabilities, they can wrap their non-probabilistic facts into tuples whose first element is a simple probability.
For example, if originally we have a fact <code>1</code>, wrapping it with a corresponding probability gives us <code>(0.1, 1)</code>, where <code>0.1</code> is the probability.</p>
<pre><code class="language-py">ctx.add_facts(&quot;digit&quot;, [1, 2, 3])                      # without probability
ctx.add_facts(&quot;digit&quot;, [(0.1, 1), (0.2, 2), (0.7, 3)]) # with probability
</code></pre>
<p>Of course, if the original facts are tuples, the ones with probability will be required to wrap further:</p>
<pre><code class="language-py">ctx.add_facts(&quot;color&quot;, [(&quot;A&quot;, &quot;blue&quot;), (&quot;A&quot;, &quot;green&quot;), ...])               # without probability
ctx.add_facts(&quot;color&quot;, [(0.1, (&quot;A&quot;, &quot;blue&quot;)), (0.2, (&quot;A&quot;, &quot;green&quot;)), ...]) # with probability
</code></pre>
<p>We can extend this syntax into tagged facts in general.
Suppose we are using the boolean semiring (<code>boolean</code>), we are going to tag each fact using values such as <code>True</code> or <code>False</code>.</p>
<pre><code class="language-py">ctx = scallopy.Context(provenance=&quot;boolean&quot;)
ctx.add_relation(&quot;edge&quot;, (int, int))
ctx.add_facts(&quot;edge&quot;, [(True, (1, 2)), (False, (2, 3))])
</code></pre>
<h3 id="non-tagged-facts-in-tagged-context"><a class="header" href="#non-tagged-facts-in-tagged-context">Non-tagged Facts in Tagged Context</a></h3>
<h2 id="adding-rules"><a class="header" href="#adding-rules">Adding Rules</a></h2>
<h3 id="tagged-rules"><a class="header" href="#tagged-rules">Tagged Rules</a></h3>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<h2 id="additional-features"><a class="header" href="#additional-features">Additional Features</a></h2>
<p>There are more features provided by the <code>ScallopContext</code> interface.
We hereby list them for reference.</p>
<h3 id="cloning"><a class="header" href="#cloning">Cloning</a></h3>
<p>One can copy a context to create a new context.
The resulting context will contain all the program, configurations, and provenance information.</p>
<pre><code class="language-py">new_ctx = ctx.clone()
</code></pre>
<p>The cloning feature relates to pseudo-incremental computation and branching computation.
We elaborate on this in the <a href="scallopy/scallopy/branching.html">Branching Computation</a> section.</p>
<h3 id="compiling"><a class="header" href="#compiling">Compiling</a></h3>
<h3 id="iteration-count-limit"><a class="header" href="#iteration-count-limit">Iteration Count Limit</a></h3>
<p>One can configure the</p>
<h3 id="early-discarding"><a class="header" href="#early-discarding">Early Discarding</a></h3>
<h3 id="obtaining-context-information"><a class="header" href="#obtaining-context-information">Obtaining Context Information</a></h3>
<h3 id="foreign-functions-and-predicates"><a class="header" href="#foreign-functions-and-predicates">Foreign Functions and Predicates</a></h3>
<h3 id="saving-and-loading"><a class="header" href="#saving-and-loading">Saving and Loading</a></h3>
<p>Please refer to the <a href="scallopy/scallopy/save_and_load.html">Saving and Loading</a> section for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="branching-executions"><a class="header" href="#branching-executions">Branching Executions</a></h1>
<p>One cool feature that <code>scallopy</code> supports is <em>branching execution</em>.
People can create a context, clone it to form new contexts, and modify the new context without touching the old ones.
This is particularly useful when incremental computation is desired.</p>
<pre><code class="language-py"># Create the first version of the context
ctx = scallopy.ScallopContext()
ctx.add_relation(...)
ctx.add_facts(...)

# Branch it into another context
ctx1 = ctx.clone()
ctx1.add_relation(...)
ctx1.add_facts(...)
ctx1.run() # Running the first context

# Branch it into one more context; `ctx1` and `ctx2` are completely disjoint
ctx2 = ctx.clone()
ctx2.add_relation(...)
ctx2.add_facts(...)
ctx2.run() # Running the second context
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-provenance"><a class="header" href="#configuring-provenance">Configuring Provenance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-functions-1"><a class="header" href="#foreign-functions-1">Foreign Functions</a></h1>
<p>While there are existing <a href="scallopy/../language/foreign_functions.html">foreign functions</a> such as <code>$hash</code> and <code>$abs</code>, people sometimes want more functions to be included for specialized computation.
<code>scallopy</code> provides such interface and allows user to define foreign functions in Python.
Here is an example defining a custom <code>$sum</code> function in Python which is later used in Scallop:</p>
<pre><code class="language-py"># Create a new foreign function by annotating an existing function with `@scallopy.foreign_function`
# Note that this function has variable arguments!
@scallopy.foreign_function
def my_sum(*args: int) -&gt; int:
  s = 0
  for x in args:
    s += x
  return s

# Create a context
ctx = scallopy.ScallopContext()

# Register the declared foreign function (`my_sum`)
# Note that the function needs to be registered before it is used
ctx.register_foreign_function(my_sum)

# Add some relations
ctx.add_relation(&quot;I&quot;, (int, int))
ctx.add_facts(&quot;I&quot;, [(1, 2), (2, 3), (3, 4)])

# Add a rule which uses the registered function!
ctx.add_rule(&quot;R($my_sum(a, b)) = I(a, b)&quot;)

# Run the context
ctx.run()

# See the result, should be [(3,), (5,), (7,)]
print(list(ctx.relation(&quot;R&quot;)))
</code></pre>
<p>Now we elaborate on how we define new foreign functions in Python.</p>
<h2 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h2>
<p>The annotator <code>@scallopy.foreign_function</code> performs analysis of the annotated Python function and makes sure that it is accepted as a Scallop foreign function.
We require that types are annotated on all arguments and the return value.
For simplicity, Python types such as <code>int</code>, <code>bool</code>, and <code>str</code> are mapped to Scallop types (and type families) as following:</p>
<div class="table-wrapper"><table><thead><tr><th>Python type</th><th>Scallop type</th><th>Scallop base types</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>Integer</code> family</td><td><code>i8</code>, <code>i16</code>, ..., <code>u8</code>, <code>u16</code>, ..., <code>usize</code></td></tr>
<tr><td><code>float</code></td><td><code>Float</code> family</td><td><code>f32</code>, <code>f64</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>str</code></td><td><code>String</code></td><td><code>String</code></td></tr>
</tbody></table>
</div>
<p>If one desires to use a more fine-grained type</p>
<h2 id="argument-types"><a class="header" href="#argument-types">Argument Types</a></h2>
<h2 id="optional-arguments"><a class="header" href="#optional-arguments">Optional Arguments</a></h2>
<h2 id="variable-arguments"><a class="header" href="#variable-arguments">Variable Arguments</a></h2>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-cli"><a class="header" href="#scallop-cli">Scallop CLI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-interpreter-1"><a class="header" href="#scallop-interpreter-1">Scallop Interpreter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-repl"><a class="header" href="#scallop-repl">Scallop REPL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scallop-compiler"><a class="header" href="#scallop-compiler">Scallop Compiler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="full-scallop-grammar"><a class="header" href="#full-scallop-grammar">Full Scallop Grammar</a></h1>
<pre><code>SCALLOP_PROGRAM ::= ITEM*

ITEM ::= TYPE_DECL
       | RELATION_DECL
       | CONST_DECL
       | QUERY_DECL

TYPE ::= u8 | u16 | u32 | u64 | u128 | usize
       | i8 | i16 | i32 | i64 | i128 | isize
       | f32 | f64 | char | bool
       | String
       | CUSTOM_TYPE_NAME

TYPE_DECL ::= type CUSTOM_TYPE_NAME = TYPE
            | type CUSTOM_TYPE_NAME &lt;: TYPE
            | type ENUM_TYPE_NAME = VARIANT1 [= VAL1] | VARIANT2 [= VAL2] | ...
            | type ADT_TYPE_NAME = CONSTRUCTOR1(TYPE*) | CONSTRUCTOR2(TYPE*) | ...
            | type RELATION_NAME(TYPE*)
            | type RELATION_NAME(VAR1: TYPE1, VAR2: TYPE2, ...)
            | type $FUNCTION_NAME(VAR1: TYPE1, VAR2: TYPE2, ...) -&gt; TYPE_RET

CONST_DECL ::= const CONSTANT_NAME : TYPE = CONSTANT
             | const CONSTANT_NAME1 [: TYPE1] = CONSTANT1, CONSTANT_NAME2 [: TYPE2] = CONSTANT2, ...

RELATION_DECL ::= FACT_DECL
                | FACTS_SET_DECL
                | RULE_DECL

CONSTANT ::= true | false | NUMBER_LITERAL | STRING_LITERAL

CONST_TUPLE ::= CONSTANT | (CONSTANT1, CONSTANT2, ...)

FOREIGN_FN ::= hash | string_length | string_concat | substring | abs

BIN_OP ::= + | - | * | / | % | == | != | &lt;= | &lt; | &gt;= | &gt; | &amp;&amp; | || | ^

UNARY_OP ::= ! | -

CONST_EXPR ::= CONSTANT
             | CONST_EXPR BIN_OP CONST_EXPR | UNARY_OP CONST_EXPR
             | $ FOREIGN_FN(CONST_EXPR*)
             | if CONST_EXPR then CONST_EXPR else CONST_EXPR
             | ( CONST_EXPR )

TAG ::= true | false | NUMBER_LITERAL  // true/false is for boolean tags; NUMBER_LITERAL is used for probabilities

FACT_DECL ::= rel RELATION_NAME(CONST_EXPR*)         // Untagged fact
            | rel TAG :: RELATION_NAME(CONST_EXPR*)  // Tagged fact

FACTS_SET_DECL ::= rel RELATION_NAME = {CONST_TUPLE1, CONST_TUPLE2, ...}                  // Untagged tuples
                 | rel RELATION_NAME = {TAG1 :: CONST_TUPLE1, TAG2 :: CONST_TUPLE2, ...}  // Tagged tuples
                 | rel RELATION_NAME = {TAG1 :: CONST_TUPLE1; TAG2 :: CONST_TUPLE2; ...}  // Tagged tuples forming annotated disjunction

EXPR ::= VARIABLE
       | CONSTANT
       | EXPR BIN_OP EXPR | UNARY_OP EXPR
       | new CONSTRUCTOR(EXPR*)
       | $ FOREIGN_FN(EXPR*)
       | if EXPR then EXPR else EXPR
       | ( EXPR )

ATOM ::= RELATION_NAME(EXPR*)

RULE_DECL ::= rel ATOM :- FORMULA | rel ATOM = FORMULA                // Normal rule
            | rel TAG :: ATOM :- FORMULA | rel TAG :: ATOM = FORMULA  // Tagged rule

FORMULA ::= ATOM
          | not ATOM | ~ ATOM                                                   // negation
          | FORMULA1, FORMULA2, ... | FORMULA and FORMULA | FORMULA /\ FORMULA  // conjunction
          | FORMULA or FORMULA | FORMULA \/ FORMULA                             // disjunction
          | FORMULA implies FORMULA | FORMULA =&gt; FORMULA                        // implies
          | case VARIABLE is ENTITY
          | CONSTRAINT
          | AGGREGATION
          | ( FORMULA )

ENTITY ::= CONSTRUCTOR(ENTITY*)

CONSTRAINT ::= EXPR // When expression returns a boolean value

AGGREGATOR ::= count | sum | prod | min | max | exists | forall | unique

AGGREGATION ::= VAR* = AGGREGATOR(VAR* : FORMULA)                             // Normal aggregation
              | VAR* = AGGREGATOR(VAR* : FORMULA where VAR* : FORMULA)        // Aggregation with group-by condition
              | VAR* = AGGREGATOR[VAR*](VAR* : FORMULA)                       // Aggregation with arg (only applied to AGGREGATOR = min or max)
              | VAR* = AGGREGATOR[VAR*](VAR* : FORMULA where VAR* : FORMULA)  // Aggregation with arg and group-by condition (only applied to AGGREGATOR = min or max)
              | forall(VAR* : FORMULA)
              | exists(VAR* : FORMULA)

QUERY_DECL ::= query RELATION_NAME
             | query ATOM
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/hljs_scallop.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
